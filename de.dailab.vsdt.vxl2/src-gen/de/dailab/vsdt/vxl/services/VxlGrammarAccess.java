/*
 * generated by Xtext
 */
package de.dailab.vsdt.vxl.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class VxlGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class VxlTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.dailab.vsdt.vxl.Vxl.VxlTerm");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cHeadAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cHeadVxlElementParserRuleCall_0_0 = (RuleCall)cHeadAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cOperatorAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cOperatorVxlOperatorEnumRuleCall_1_0_0 = (RuleCall)cOperatorAssignment_1_0.eContents().get(0);
		private final Assignment cTailAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTailVxlTermParserRuleCall_1_1_0 = (RuleCall)cTailAssignment_1_1.eContents().get(0);
		
		//// COMPLEX TERMS
		//VxlTerm:
		//	head=VxlElement (operator=VxlOperator tail=VxlTerm)?;
		@Override public ParserRule getRule() { return rule; }

		//head=VxlElement (operator=VxlOperator tail=VxlTerm)?
		public Group getGroup() { return cGroup; }

		//head=VxlElement
		public Assignment getHeadAssignment_0() { return cHeadAssignment_0; }

		//VxlElement
		public RuleCall getHeadVxlElementParserRuleCall_0_0() { return cHeadVxlElementParserRuleCall_0_0; }

		//(operator=VxlOperator tail=VxlTerm)?
		public Group getGroup_1() { return cGroup_1; }

		//operator=VxlOperator
		public Assignment getOperatorAssignment_1_0() { return cOperatorAssignment_1_0; }

		//VxlOperator
		public RuleCall getOperatorVxlOperatorEnumRuleCall_1_0_0() { return cOperatorVxlOperatorEnumRuleCall_1_0_0; }

		//tail=VxlTerm
		public Assignment getTailAssignment_1_1() { return cTailAssignment_1_1; }

		//VxlTerm
		public RuleCall getTailVxlTermParserRuleCall_1_1_0() { return cTailVxlTermParserRuleCall_1_1_0; }
	}

	public class VxlElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.dailab.vsdt.vxl.Vxl.VxlElement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVxlBracketTermParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cVxlNegationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cVxlMinusParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cVxlValueParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cVxlVariableParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cVxlListParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cVxlMapParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cVxlCardinalityParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cVxlFunctionParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cVxlConstructorParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		
		//VxlElement:
		//	VxlBracketTerm | VxlNegation | VxlMinus | VxlValue | VxlVariable | VxlList | VxlMap | VxlCardinality | VxlFunction |
		//	VxlConstructor;
		@Override public ParserRule getRule() { return rule; }

		//VxlBracketTerm | VxlNegation | VxlMinus | VxlValue | VxlVariable | VxlList | VxlMap | VxlCardinality | VxlFunction |
		//VxlConstructor
		public Alternatives getAlternatives() { return cAlternatives; }

		//VxlBracketTerm
		public RuleCall getVxlBracketTermParserRuleCall_0() { return cVxlBracketTermParserRuleCall_0; }

		//VxlNegation
		public RuleCall getVxlNegationParserRuleCall_1() { return cVxlNegationParserRuleCall_1; }

		//VxlMinus
		public RuleCall getVxlMinusParserRuleCall_2() { return cVxlMinusParserRuleCall_2; }

		//VxlValue
		public RuleCall getVxlValueParserRuleCall_3() { return cVxlValueParserRuleCall_3; }

		//VxlVariable
		public RuleCall getVxlVariableParserRuleCall_4() { return cVxlVariableParserRuleCall_4; }

		//VxlList
		public RuleCall getVxlListParserRuleCall_5() { return cVxlListParserRuleCall_5; }

		//VxlMap
		public RuleCall getVxlMapParserRuleCall_6() { return cVxlMapParserRuleCall_6; }

		//VxlCardinality
		public RuleCall getVxlCardinalityParserRuleCall_7() { return cVxlCardinalityParserRuleCall_7; }

		//VxlFunction
		public RuleCall getVxlFunctionParserRuleCall_8() { return cVxlFunctionParserRuleCall_8; }

		//VxlConstructor
		public RuleCall getVxlConstructorParserRuleCall_9() { return cVxlConstructorParserRuleCall_9; }
	}

	public class VxlBracketTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.dailab.vsdt.vxl.Vxl.VxlBracketTerm");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTermAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTermVxlTermParserRuleCall_1_0 = (RuleCall)cTermAssignment_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//// SPECIAL TERMS, UNARY OPERATORS
		//VxlBracketTerm:
		//	"(" term=VxlTerm ")";
		@Override public ParserRule getRule() { return rule; }

		//"(" term=VxlTerm ")"
		public Group getGroup() { return cGroup; }

		//"("
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }

		//term=VxlTerm
		public Assignment getTermAssignment_1() { return cTermAssignment_1; }

		//VxlTerm
		public RuleCall getTermVxlTermParserRuleCall_1_0() { return cTermVxlTermParserRuleCall_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}

	public class VxlNegationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.dailab.vsdt.vxl.Vxl.VxlNegation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNotKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cElementAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cElementVxlElementParserRuleCall_1_0 = (RuleCall)cElementAssignment_1.eContents().get(0);
		
		//VxlNegation:
		//	"not" element=VxlElement;
		@Override public ParserRule getRule() { return rule; }

		//"not" element=VxlElement
		public Group getGroup() { return cGroup; }

		//"not"
		public Keyword getNotKeyword_0() { return cNotKeyword_0; }

		//element=VxlElement
		public Assignment getElementAssignment_1() { return cElementAssignment_1; }

		//VxlElement
		public RuleCall getElementVxlElementParserRuleCall_1_0() { return cElementVxlElementParserRuleCall_1_0; }
	}

	public class VxlMinusElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.dailab.vsdt.vxl.Vxl.VxlMinus");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cElementAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cElementVxlElementParserRuleCall_1_0 = (RuleCall)cElementAssignment_1.eContents().get(0);
		
		//VxlMinus:
		//	"-" element=VxlElement;
		@Override public ParserRule getRule() { return rule; }

		//"-" element=VxlElement
		public Group getGroup() { return cGroup; }

		//"-"
		public Keyword getHyphenMinusKeyword_0() { return cHyphenMinusKeyword_0; }

		//element=VxlElement
		public Assignment getElementAssignment_1() { return cElementAssignment_1; }

		//VxlElement
		public RuleCall getElementVxlElementParserRuleCall_1_0() { return cElementVxlElementParserRuleCall_1_0; }
	}

	public class VxlCardinalityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.dailab.vsdt.vxl.Vxl.VxlCardinality");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNumberSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cElementAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cElementVxlElementParserRuleCall_1_0 = (RuleCall)cElementAssignment_1.eContents().get(0);
		
		//VxlCardinality:
		//	"#" element=VxlElement;
		@Override public ParserRule getRule() { return rule; }

		//"#" element=VxlElement
		public Group getGroup() { return cGroup; }

		//"#"
		public Keyword getNumberSignKeyword_0() { return cNumberSignKeyword_0; }

		//element=VxlElement
		public Assignment getElementAssignment_1() { return cElementAssignment_1; }

		//VxlElement
		public RuleCall getElementVxlElementParserRuleCall_1_0() { return cElementVxlElementParserRuleCall_1_0; }
	}

	public class VxlVariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.dailab.vsdt.vxl.Vxl.VxlVariable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Assignment cAccessorAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cAccessorVxlAccessorParserRuleCall_1_0 = (RuleCall)cAccessorAssignment_1.eContents().get(0);
		
		//// VARIABLES & ACCESSORS
		//VxlVariable:
		//	name=ID accessor=VxlAccessor?;
		@Override public ParserRule getRule() { return rule; }

		//name=ID accessor=VxlAccessor?
		public Group getGroup() { return cGroup; }

		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }

		//accessor=VxlAccessor?
		public Assignment getAccessorAssignment_1() { return cAccessorAssignment_1; }

		//VxlAccessor
		public RuleCall getAccessorVxlAccessorParserRuleCall_1_0() { return cAccessorVxlAccessorParserRuleCall_1_0; }
	}

	public class VxlAccessorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.dailab.vsdt.vxl.Vxl.VxlAccessor");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVxlArrayAccessorParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cVxlFieldAccessorParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cVxlMethodAccessorParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//VxlAccessor:
		//	VxlArrayAccessor | VxlFieldAccessor | VxlMethodAccessor;
		@Override public ParserRule getRule() { return rule; }

		//VxlArrayAccessor | VxlFieldAccessor | VxlMethodAccessor
		public Alternatives getAlternatives() { return cAlternatives; }

		//VxlArrayAccessor
		public RuleCall getVxlArrayAccessorParserRuleCall_0() { return cVxlArrayAccessorParserRuleCall_0; }

		//VxlFieldAccessor
		public RuleCall getVxlFieldAccessorParserRuleCall_1() { return cVxlFieldAccessorParserRuleCall_1; }

		//VxlMethodAccessor
		public RuleCall getVxlMethodAccessorParserRuleCall_2() { return cVxlMethodAccessorParserRuleCall_2; }
	}

	public class VxlArrayAccessorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.dailab.vsdt.vxl.Vxl.VxlArrayAccessor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cIndexAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIndexVxlTermParserRuleCall_1_0 = (RuleCall)cIndexAssignment_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cAccessorAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cAccessorVxlAccessorParserRuleCall_3_0 = (RuleCall)cAccessorAssignment_3.eContents().get(0);
		
		//VxlArrayAccessor:
		//	"[" index=VxlTerm "]" accessor=VxlAccessor?;
		@Override public ParserRule getRule() { return rule; }

		//"[" index=VxlTerm "]" accessor=VxlAccessor?
		public Group getGroup() { return cGroup; }

		//"["
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }

		//index=VxlTerm
		public Assignment getIndexAssignment_1() { return cIndexAssignment_1; }

		//VxlTerm
		public RuleCall getIndexVxlTermParserRuleCall_1_0() { return cIndexVxlTermParserRuleCall_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_2() { return cRightSquareBracketKeyword_2; }

		//accessor=VxlAccessor?
		public Assignment getAccessorAssignment_3() { return cAccessorAssignment_3; }

		//VxlAccessor
		public RuleCall getAccessorVxlAccessorParserRuleCall_3_0() { return cAccessorVxlAccessorParserRuleCall_3_0; }
	}

	public class VxlFieldAccessorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.dailab.vsdt.vxl.Vxl.VxlFieldAccessor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFullStopKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cAccessorAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cAccessorVxlAccessorParserRuleCall_2_0 = (RuleCall)cAccessorAssignment_2.eContents().get(0);
		
		//VxlFieldAccessor:
		//	"." name=ID accessor=VxlAccessor?;
		@Override public ParserRule getRule() { return rule; }

		//"." name=ID accessor=VxlAccessor?
		public Group getGroup() { return cGroup; }

		//"."
		public Keyword getFullStopKeyword_0() { return cFullStopKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//accessor=VxlAccessor?
		public Assignment getAccessorAssignment_2() { return cAccessorAssignment_2; }

		//VxlAccessor
		public RuleCall getAccessorVxlAccessorParserRuleCall_2_0() { return cAccessorVxlAccessorParserRuleCall_2_0; }
	}

	public class VxlMethodAccessorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.dailab.vsdt.vxl.Vxl.VxlMethodAccessor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFullStopKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cFunctionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFunctionVxlFunctionParserRuleCall_1_0 = (RuleCall)cFunctionAssignment_1.eContents().get(0);
		private final Assignment cAccessorAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cAccessorVxlAccessorParserRuleCall_2_0 = (RuleCall)cAccessorAssignment_2.eContents().get(0);
		
		//VxlMethodAccessor:
		//	"." function=VxlFunction accessor=VxlAccessor?;
		@Override public ParserRule getRule() { return rule; }

		//"." function=VxlFunction accessor=VxlAccessor?
		public Group getGroup() { return cGroup; }

		//"."
		public Keyword getFullStopKeyword_0() { return cFullStopKeyword_0; }

		//function=VxlFunction
		public Assignment getFunctionAssignment_1() { return cFunctionAssignment_1; }

		//VxlFunction
		public RuleCall getFunctionVxlFunctionParserRuleCall_1_0() { return cFunctionVxlFunctionParserRuleCall_1_0; }

		//accessor=VxlAccessor?
		public Assignment getAccessorAssignment_2() { return cAccessorAssignment_2; }

		//VxlAccessor
		public RuleCall getAccessorVxlAccessorParserRuleCall_2_0() { return cAccessorVxlAccessorParserRuleCall_2_0; }
	}

	public class VxlListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.dailab.vsdt.vxl.Vxl.VxlList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cEmptyAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final Keyword cEmptyRightSquareBracketKeyword_1_0_0 = (Keyword)cEmptyAssignment_1_0.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Assignment cBodyAssignment_1_1_0 = (Assignment)cGroup_1_1.eContents().get(0);
		private final RuleCall cBodyVxlListElementParserRuleCall_1_1_0_0 = (RuleCall)cBodyAssignment_1_1_0.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_1_1 = (Keyword)cGroup_1_1.eContents().get(1);
		
		//// LISTS
		//VxlList:
		//	"[" (empty?="]" | body=VxlListElement "]");
		@Override public ParserRule getRule() { return rule; }

		//"[" (empty?="]" | body=VxlListElement "]")
		public Group getGroup() { return cGroup; }

		//"["
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }

		//(empty?="]" | body=VxlListElement "]")
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//empty?="]"
		public Assignment getEmptyAssignment_1_0() { return cEmptyAssignment_1_0; }

		//"]"
		public Keyword getEmptyRightSquareBracketKeyword_1_0_0() { return cEmptyRightSquareBracketKeyword_1_0_0; }

		//body=VxlListElement "]"
		public Group getGroup_1_1() { return cGroup_1_1; }

		//body=VxlListElement
		public Assignment getBodyAssignment_1_1_0() { return cBodyAssignment_1_1_0; }

		//VxlListElement
		public RuleCall getBodyVxlListElementParserRuleCall_1_1_0_0() { return cBodyVxlListElementParserRuleCall_1_1_0_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_1_1_1() { return cRightSquareBracketKeyword_1_1_1; }
	}

	public class VxlListElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.dailab.vsdt.vxl.Vxl.VxlListElement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFirstAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cFirstVxlTermParserRuleCall_0_0 = (RuleCall)cFirstAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cRestAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRestVxlListElementParserRuleCall_1_1_0 = (RuleCall)cRestAssignment_1_1.eContents().get(0);
		
		//VxlListElement:
		//	first=VxlTerm ("," rest=VxlListElement)?;
		@Override public ParserRule getRule() { return rule; }

		//first=VxlTerm ("," rest=VxlListElement)?
		public Group getGroup() { return cGroup; }

		//first=VxlTerm
		public Assignment getFirstAssignment_0() { return cFirstAssignment_0; }

		//VxlTerm
		public RuleCall getFirstVxlTermParserRuleCall_0_0() { return cFirstVxlTermParserRuleCall_0_0; }

		//("," rest=VxlListElement)?
		public Group getGroup_1() { return cGroup_1; }

		//","
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }

		//rest=VxlListElement
		public Assignment getRestAssignment_1_1() { return cRestAssignment_1_1; }

		//VxlListElement
		public RuleCall getRestVxlListElementParserRuleCall_1_1_0() { return cRestVxlListElementParserRuleCall_1_1_0; }
	}

	public class VxlMapElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.dailab.vsdt.vxl.Vxl.VxlMap");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cEmptyAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final Keyword cEmptyRightCurlyBracketKeyword_1_0_0 = (Keyword)cEmptyAssignment_1_0.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Assignment cBodyAssignment_1_1_0 = (Assignment)cGroup_1_1.eContents().get(0);
		private final RuleCall cBodyVxlMapElementParserRuleCall_1_1_0_0 = (RuleCall)cBodyAssignment_1_1_0.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_1_1_1 = (Keyword)cGroup_1_1.eContents().get(1);
		
		//// MAPS
		//VxlMap:
		//	"{" (empty?="}" | body=VxlMapElement "}");
		@Override public ParserRule getRule() { return rule; }

		//"{" (empty?="}" | body=VxlMapElement "}")
		public Group getGroup() { return cGroup; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_0() { return cLeftCurlyBracketKeyword_0; }

		//(empty?="}" | body=VxlMapElement "}")
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//empty?="}"
		public Assignment getEmptyAssignment_1_0() { return cEmptyAssignment_1_0; }

		//"}"
		public Keyword getEmptyRightCurlyBracketKeyword_1_0_0() { return cEmptyRightCurlyBracketKeyword_1_0_0; }

		//body=VxlMapElement "}"
		public Group getGroup_1_1() { return cGroup_1_1; }

		//body=VxlMapElement
		public Assignment getBodyAssignment_1_1_0() { return cBodyAssignment_1_1_0; }

		//VxlMapElement
		public RuleCall getBodyVxlMapElementParserRuleCall_1_1_0_0() { return cBodyVxlMapElementParserRuleCall_1_1_0_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_1_1_1() { return cRightCurlyBracketKeyword_1_1_1; }
	}

	public class VxlMapElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.dailab.vsdt.vxl.Vxl.VxlMapElement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cKeyAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cKeyVxlTermParserRuleCall_0_0 = (RuleCall)cKeyAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueVxlTermParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cRestAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cRestVxlMapElementParserRuleCall_3_1_0 = (RuleCall)cRestAssignment_3_1.eContents().get(0);
		
		//VxlMapElement:
		//	key=VxlTerm ":" value=VxlTerm ("," rest=VxlMapElement)?;
		@Override public ParserRule getRule() { return rule; }

		//key=VxlTerm ":" value=VxlTerm ("," rest=VxlMapElement)?
		public Group getGroup() { return cGroup; }

		//key=VxlTerm
		public Assignment getKeyAssignment_0() { return cKeyAssignment_0; }

		//VxlTerm
		public RuleCall getKeyVxlTermParserRuleCall_0_0() { return cKeyVxlTermParserRuleCall_0_0; }

		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }

		//value=VxlTerm
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }

		//VxlTerm
		public RuleCall getValueVxlTermParserRuleCall_2_0() { return cValueVxlTermParserRuleCall_2_0; }

		//("," rest=VxlMapElement)?
		public Group getGroup_3() { return cGroup_3; }

		//","
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }

		//rest=VxlMapElement
		public Assignment getRestAssignment_3_1() { return cRestAssignment_3_1; }

		//VxlMapElement
		public RuleCall getRestVxlMapElementParserRuleCall_3_1_0() { return cRestVxlMapElementParserRuleCall_3_1_0; }
	}

	public class VxlFunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.dailab.vsdt.vxl.Vxl.VxlFunction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cEmptyAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final Keyword cEmptyRightParenthesisKeyword_2_0_0 = (Keyword)cEmptyAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cAlternatives_2.eContents().get(1);
		private final Assignment cBodyAssignment_2_1_0 = (Assignment)cGroup_2_1.eContents().get(0);
		private final RuleCall cBodyVxlListElementParserRuleCall_2_1_0_0 = (RuleCall)cBodyAssignment_2_1_0.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_1_1 = (Keyword)cGroup_2_1.eContents().get(1);
		
		//// FUNCTIONS
		//VxlFunction:
		//	name=ID "(" (empty?=")" | body=VxlListElement ")");
		@Override public ParserRule getRule() { return rule; }

		//name=ID "(" (empty?=")" | body=VxlListElement ")")
		public Group getGroup() { return cGroup; }

		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//(empty?=")" | body=VxlListElement ")")
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//empty?=")"
		public Assignment getEmptyAssignment_2_0() { return cEmptyAssignment_2_0; }

		//")"
		public Keyword getEmptyRightParenthesisKeyword_2_0_0() { return cEmptyRightParenthesisKeyword_2_0_0; }

		//body=VxlListElement ")"
		public Group getGroup_2_1() { return cGroup_2_1; }

		//body=VxlListElement
		public Assignment getBodyAssignment_2_1_0() { return cBodyAssignment_2_1_0; }

		//VxlListElement
		public RuleCall getBodyVxlListElementParserRuleCall_2_1_0_0() { return cBodyVxlListElementParserRuleCall_2_1_0_0; }

		//")"
		public Keyword getRightParenthesisKeyword_2_1_1() { return cRightParenthesisKeyword_2_1_1; }
	}

	public class VxlConstructorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.dailab.vsdt.vxl.Vxl.VxlConstructor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNewKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameFULLY_QUALIFIEDParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Alternatives cAlternatives_3 = (Alternatives)cGroup.eContents().get(3);
		private final Assignment cEmptyAssignment_3_0 = (Assignment)cAlternatives_3.eContents().get(0);
		private final Keyword cEmptyRightParenthesisKeyword_3_0_0 = (Keyword)cEmptyAssignment_3_0.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cAlternatives_3.eContents().get(1);
		private final Assignment cBodyAssignment_3_1_0 = (Assignment)cGroup_3_1.eContents().get(0);
		private final RuleCall cBodyVxlListElementParserRuleCall_3_1_0_0 = (RuleCall)cBodyAssignment_3_1_0.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3_1_1 = (Keyword)cGroup_3_1.eContents().get(1);
		
		//VxlConstructor:
		//	"new" name=FULLY_QUALIFIED "(" (empty?=")" | body=VxlListElement ")");
		@Override public ParserRule getRule() { return rule; }

		//"new" name=FULLY_QUALIFIED "(" (empty?=")" | body=VxlListElement ")")
		public Group getGroup() { return cGroup; }

		//"new"
		public Keyword getNewKeyword_0() { return cNewKeyword_0; }

		//name=FULLY_QUALIFIED
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//FULLY_QUALIFIED
		public RuleCall getNameFULLY_QUALIFIEDParserRuleCall_1_0() { return cNameFULLY_QUALIFIEDParserRuleCall_1_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//(empty?=")" | body=VxlListElement ")")
		public Alternatives getAlternatives_3() { return cAlternatives_3; }

		//empty?=")"
		public Assignment getEmptyAssignment_3_0() { return cEmptyAssignment_3_0; }

		//")"
		public Keyword getEmptyRightParenthesisKeyword_3_0_0() { return cEmptyRightParenthesisKeyword_3_0_0; }

		//body=VxlListElement ")"
		public Group getGroup_3_1() { return cGroup_3_1; }

		//body=VxlListElement
		public Assignment getBodyAssignment_3_1_0() { return cBodyAssignment_3_1_0; }

		//VxlListElement
		public RuleCall getBodyVxlListElementParserRuleCall_3_1_0_0() { return cBodyVxlListElementParserRuleCall_3_1_0_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3_1_1() { return cRightParenthesisKeyword_3_1_1; }
	}

	public class VxlValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.dailab.vsdt.vxl.Vxl.VxlValue");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVxlNullConstParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cVxlBooleanConstParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cVxlNumericConstParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cVxlStringConstParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//// CONSTANT VALUES
		//VxlValue:
		//	VxlNullConst | VxlBooleanConst | VxlNumericConst | VxlStringConst;
		@Override public ParserRule getRule() { return rule; }

		//VxlNullConst | VxlBooleanConst | VxlNumericConst | VxlStringConst
		public Alternatives getAlternatives() { return cAlternatives; }

		//VxlNullConst
		public RuleCall getVxlNullConstParserRuleCall_0() { return cVxlNullConstParserRuleCall_0; }

		//VxlBooleanConst
		public RuleCall getVxlBooleanConstParserRuleCall_1() { return cVxlBooleanConstParserRuleCall_1; }

		//VxlNumericConst
		public RuleCall getVxlNumericConstParserRuleCall_2() { return cVxlNumericConstParserRuleCall_2; }

		//VxlStringConst
		public RuleCall getVxlStringConstParserRuleCall_3() { return cVxlStringConstParserRuleCall_3; }
	}

	public class VxlBooleanConstElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.dailab.vsdt.vxl.Vxl.VxlBooleanConst");
		private final Assignment cConstAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cConstAlternatives_0 = (Alternatives)cConstAssignment.eContents().get(0);
		private final Keyword cConstTrueKeyword_0_0 = (Keyword)cConstAlternatives_0.eContents().get(0);
		private final Keyword cConstFalseKeyword_0_1 = (Keyword)cConstAlternatives_0.eContents().get(1);
		
		//VxlBooleanConst:
		//	const=('true' | 'false');
		@Override public ParserRule getRule() { return rule; }

		//const=('true' | 'false')
		public Assignment getConstAssignment() { return cConstAssignment; }

		//('true' | 'false')
		public Alternatives getConstAlternatives_0() { return cConstAlternatives_0; }

		//'true'
		public Keyword getConstTrueKeyword_0_0() { return cConstTrueKeyword_0_0; }

		//'false'
		public Keyword getConstFalseKeyword_0_1() { return cConstFalseKeyword_0_1; }
	}

	public class VxlNullConstElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.dailab.vsdt.vxl.Vxl.VxlNullConst");
		private final Assignment cConstAssignment = (Assignment)rule.eContents().get(1);
		private final Keyword cConstNullKeyword_0 = (Keyword)cConstAssignment.eContents().get(0);
		
		//VxlNullConst:
		//	const="null";
		@Override public ParserRule getRule() { return rule; }

		//const="null"
		public Assignment getConstAssignment() { return cConstAssignment; }

		//"null"
		public Keyword getConstNullKeyword_0() { return cConstNullKeyword_0; }
	}

	public class VxlNumericConstElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.dailab.vsdt.vxl.Vxl.VxlNumericConst");
		private final Assignment cConstAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cConstNUMERICParserRuleCall_0 = (RuleCall)cConstAssignment.eContents().get(0);
		
		//VxlNumericConst:
		//	const=NUMERIC;
		@Override public ParserRule getRule() { return rule; }

		//const=NUMERIC
		public Assignment getConstAssignment() { return cConstAssignment; }

		//NUMERIC
		public RuleCall getConstNUMERICParserRuleCall_0() { return cConstNUMERICParserRuleCall_0; }
	}

	public class VxlStringConstElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.dailab.vsdt.vxl.Vxl.VxlStringConst");
		private final Assignment cConstAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cConstSTRINGTerminalRuleCall_0 = (RuleCall)cConstAssignment.eContents().get(0);
		
		//VxlStringConst:
		//	const=STRING;
		@Override public ParserRule getRule() { return rule; }

		//const=STRING
		public Assignment getConstAssignment() { return cConstAssignment; }

		//STRING
		public RuleCall getConstSTRINGTerminalRuleCall_0() { return cConstSTRINGTerminalRuleCall_0; }
	}

	public class NUMERICElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.dailab.vsdt.vxl.Vxl.NUMERIC");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//// String ** String -> String
		//// NATIVES
		//NUMERIC:
		//	INT ('.' INT)?;
		@Override public ParserRule getRule() { return rule; }

		//INT ('.' INT)?
		public Group getGroup() { return cGroup; }

		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }

		//('.' INT)?
		public Group getGroup_1() { return cGroup_1; }

		//'.'
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }

		//INT
		public RuleCall getINTTerminalRuleCall_1_1() { return cINTTerminalRuleCall_1_1; }
	}

	public class FULLY_QUALIFIEDElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.dailab.vsdt.vxl.Vxl.FULLY_QUALIFIED");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cFULLY_QUALIFIEDParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//FULLY_QUALIFIED:
		//	ID ('.' FULLY_QUALIFIED)?;
		@Override public ParserRule getRule() { return rule; }

		//ID ('.' FULLY_QUALIFIED)?
		public Group getGroup() { return cGroup; }

		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }

		//('.' FULLY_QUALIFIED)?
		public Group getGroup_1() { return cGroup_1; }

		//'.'
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }

		//FULLY_QUALIFIED
		public RuleCall getFULLY_QUALIFIEDParserRuleCall_1_1() { return cFULLY_QUALIFIEDParserRuleCall_1_1; }
	}
	
	
	public class VxlOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "de.dailab.vsdt.vxl.Vxl.VxlOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cLTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cLTLessThanSignKeyword_0_0 = (Keyword)cLTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cLEEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cLELessThanSignEqualsSignKeyword_1_0 = (Keyword)cLEEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cEQEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cEQEqualsSignEqualsSignKeyword_2_0 = (Keyword)cEQEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cNEQEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cNEQExclamationMarkEqualsSignKeyword_3_0 = (Keyword)cNEQEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cGTEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cGTGreaterThanSignKeyword_4_0 = (Keyword)cGTEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cGEEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cGEGreaterThanSignEqualsSignKeyword_5_0 = (Keyword)cGEEnumLiteralDeclaration_5.eContents().get(0);
		private final EnumLiteralDeclaration cADDEnumLiteralDeclaration_6 = (EnumLiteralDeclaration)cAlternatives.eContents().get(6);
		private final Keyword cADDPlusSignKeyword_6_0 = (Keyword)cADDEnumLiteralDeclaration_6.eContents().get(0);
		private final EnumLiteralDeclaration cSUBEnumLiteralDeclaration_7 = (EnumLiteralDeclaration)cAlternatives.eContents().get(7);
		private final Keyword cSUBHyphenMinusKeyword_7_0 = (Keyword)cSUBEnumLiteralDeclaration_7.eContents().get(0);
		private final EnumLiteralDeclaration cMULTEnumLiteralDeclaration_8 = (EnumLiteralDeclaration)cAlternatives.eContents().get(8);
		private final Keyword cMULTAsteriskKeyword_8_0 = (Keyword)cMULTEnumLiteralDeclaration_8.eContents().get(0);
		private final EnumLiteralDeclaration cDIVEnumLiteralDeclaration_9 = (EnumLiteralDeclaration)cAlternatives.eContents().get(9);
		private final Keyword cDIVSolidusKeyword_9_0 = (Keyword)cDIVEnumLiteralDeclaration_9.eContents().get(0);
		private final EnumLiteralDeclaration cMODEnumLiteralDeclaration_10 = (EnumLiteralDeclaration)cAlternatives.eContents().get(10);
		private final Keyword cMODPercentSignKeyword_10_0 = (Keyword)cMODEnumLiteralDeclaration_10.eContents().get(0);
		private final EnumLiteralDeclaration cANDEnumLiteralDeclaration_11 = (EnumLiteralDeclaration)cAlternatives.eContents().get(11);
		private final Keyword cANDAndKeyword_11_0 = (Keyword)cANDEnumLiteralDeclaration_11.eContents().get(0);
		private final EnumLiteralDeclaration cOREnumLiteralDeclaration_12 = (EnumLiteralDeclaration)cAlternatives.eContents().get(12);
		private final Keyword cOROrKeyword_12_0 = (Keyword)cOREnumLiteralDeclaration_12.eContents().get(0);
		private final EnumLiteralDeclaration cCONCATEnumLiteralDeclaration_13 = (EnumLiteralDeclaration)cAlternatives.eContents().get(13);
		private final Keyword cCONCATPlusSignPlusSignKeyword_13_0 = (Keyword)cCONCATEnumLiteralDeclaration_13.eContents().get(0);
		
		//enum VxlOperator:
		//	LT="<" | LE="<=" | EQ="==" | NEQ="!=" | GT=">" | GE=">=" | // Term ** Term -> Bool
		//	ADD="+" | SUB="-" | MULT="*" | DIV="/" | MOD="%" | // Num ** Num -> Num
		//	AND="and" | OR="or" | // Bool ** Bool -> Bool
		//	CONCAT="++";
		public EnumRule getRule() { return rule; }

		//LT="<" | LE="<=" | EQ="==" | NEQ="!=" | GT=">" | GE=">=" | // Term ** Term -> Bool
		//ADD="+" | SUB="-" | MULT="*" | DIV="/" | MOD="%" | // Num ** Num -> Num
		//AND="and" | OR="or" | // Bool ** Bool -> Bool
		//CONCAT="++"
		public Alternatives getAlternatives() { return cAlternatives; }

		//LT="<"
		public EnumLiteralDeclaration getLTEnumLiteralDeclaration_0() { return cLTEnumLiteralDeclaration_0; }

		//"<"
		public Keyword getLTLessThanSignKeyword_0_0() { return cLTLessThanSignKeyword_0_0; }

		//LE="<="
		public EnumLiteralDeclaration getLEEnumLiteralDeclaration_1() { return cLEEnumLiteralDeclaration_1; }

		//"<="
		public Keyword getLELessThanSignEqualsSignKeyword_1_0() { return cLELessThanSignEqualsSignKeyword_1_0; }

		//EQ="=="
		public EnumLiteralDeclaration getEQEnumLiteralDeclaration_2() { return cEQEnumLiteralDeclaration_2; }

		//"=="
		public Keyword getEQEqualsSignEqualsSignKeyword_2_0() { return cEQEqualsSignEqualsSignKeyword_2_0; }

		//NEQ="!="
		public EnumLiteralDeclaration getNEQEnumLiteralDeclaration_3() { return cNEQEnumLiteralDeclaration_3; }

		//"!="
		public Keyword getNEQExclamationMarkEqualsSignKeyword_3_0() { return cNEQExclamationMarkEqualsSignKeyword_3_0; }

		//GT=">"
		public EnumLiteralDeclaration getGTEnumLiteralDeclaration_4() { return cGTEnumLiteralDeclaration_4; }

		//">"
		public Keyword getGTGreaterThanSignKeyword_4_0() { return cGTGreaterThanSignKeyword_4_0; }

		//GE=">="
		public EnumLiteralDeclaration getGEEnumLiteralDeclaration_5() { return cGEEnumLiteralDeclaration_5; }

		//">="
		public Keyword getGEGreaterThanSignEqualsSignKeyword_5_0() { return cGEGreaterThanSignEqualsSignKeyword_5_0; }

		//// Term ** Term -> Bool
		//ADD="+"
		public EnumLiteralDeclaration getADDEnumLiteralDeclaration_6() { return cADDEnumLiteralDeclaration_6; }

		//"+"
		public Keyword getADDPlusSignKeyword_6_0() { return cADDPlusSignKeyword_6_0; }

		//SUB="-"
		public EnumLiteralDeclaration getSUBEnumLiteralDeclaration_7() { return cSUBEnumLiteralDeclaration_7; }

		//"-"
		public Keyword getSUBHyphenMinusKeyword_7_0() { return cSUBHyphenMinusKeyword_7_0; }

		//MULT="*"
		public EnumLiteralDeclaration getMULTEnumLiteralDeclaration_8() { return cMULTEnumLiteralDeclaration_8; }

		//"*"
		public Keyword getMULTAsteriskKeyword_8_0() { return cMULTAsteriskKeyword_8_0; }

		//DIV="/"
		public EnumLiteralDeclaration getDIVEnumLiteralDeclaration_9() { return cDIVEnumLiteralDeclaration_9; }

		//"/"
		public Keyword getDIVSolidusKeyword_9_0() { return cDIVSolidusKeyword_9_0; }

		//MOD="%"
		public EnumLiteralDeclaration getMODEnumLiteralDeclaration_10() { return cMODEnumLiteralDeclaration_10; }

		//"%"
		public Keyword getMODPercentSignKeyword_10_0() { return cMODPercentSignKeyword_10_0; }

		//// Num ** Num -> Num
		//AND="and"
		public EnumLiteralDeclaration getANDEnumLiteralDeclaration_11() { return cANDEnumLiteralDeclaration_11; }

		//"and"
		public Keyword getANDAndKeyword_11_0() { return cANDAndKeyword_11_0; }

		//OR="or"
		public EnumLiteralDeclaration getOREnumLiteralDeclaration_12() { return cOREnumLiteralDeclaration_12; }

		//"or"
		public Keyword getOROrKeyword_12_0() { return cOROrKeyword_12_0; }

		//// Bool ** Bool -> Bool
		//CONCAT="++"
		public EnumLiteralDeclaration getCONCATEnumLiteralDeclaration_13() { return cCONCATEnumLiteralDeclaration_13; }

		//"++"
		public Keyword getCONCATPlusSignPlusSignKeyword_13_0() { return cCONCATPlusSignPlusSignKeyword_13_0; }
	}
	
	private final VxlTermElements pVxlTerm;
	private final VxlElementElements pVxlElement;
	private final VxlBracketTermElements pVxlBracketTerm;
	private final VxlNegationElements pVxlNegation;
	private final VxlMinusElements pVxlMinus;
	private final VxlCardinalityElements pVxlCardinality;
	private final VxlVariableElements pVxlVariable;
	private final VxlAccessorElements pVxlAccessor;
	private final VxlArrayAccessorElements pVxlArrayAccessor;
	private final VxlFieldAccessorElements pVxlFieldAccessor;
	private final VxlMethodAccessorElements pVxlMethodAccessor;
	private final VxlListElements pVxlList;
	private final VxlListElementElements pVxlListElement;
	private final VxlMapElements pVxlMap;
	private final VxlMapElementElements pVxlMapElement;
	private final VxlFunctionElements pVxlFunction;
	private final VxlConstructorElements pVxlConstructor;
	private final VxlValueElements pVxlValue;
	private final VxlBooleanConstElements pVxlBooleanConst;
	private final VxlNullConstElements pVxlNullConst;
	private final VxlNumericConstElements pVxlNumericConst;
	private final VxlStringConstElements pVxlStringConst;
	private final VxlOperatorElements eVxlOperator;
	private final NUMERICElements pNUMERIC;
	private final FULLY_QUALIFIEDElements pFULLY_QUALIFIED;
	
	private final Grammar grammar;

	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public VxlGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pVxlTerm = new VxlTermElements();
		this.pVxlElement = new VxlElementElements();
		this.pVxlBracketTerm = new VxlBracketTermElements();
		this.pVxlNegation = new VxlNegationElements();
		this.pVxlMinus = new VxlMinusElements();
		this.pVxlCardinality = new VxlCardinalityElements();
		this.pVxlVariable = new VxlVariableElements();
		this.pVxlAccessor = new VxlAccessorElements();
		this.pVxlArrayAccessor = new VxlArrayAccessorElements();
		this.pVxlFieldAccessor = new VxlFieldAccessorElements();
		this.pVxlMethodAccessor = new VxlMethodAccessorElements();
		this.pVxlList = new VxlListElements();
		this.pVxlListElement = new VxlListElementElements();
		this.pVxlMap = new VxlMapElements();
		this.pVxlMapElement = new VxlMapElementElements();
		this.pVxlFunction = new VxlFunctionElements();
		this.pVxlConstructor = new VxlConstructorElements();
		this.pVxlValue = new VxlValueElements();
		this.pVxlBooleanConst = new VxlBooleanConstElements();
		this.pVxlNullConst = new VxlNullConstElements();
		this.pVxlNumericConst = new VxlNumericConstElements();
		this.pVxlStringConst = new VxlStringConstElements();
		this.eVxlOperator = new VxlOperatorElements();
		this.pNUMERIC = new NUMERICElements();
		this.pFULLY_QUALIFIED = new FULLY_QUALIFIEDElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("de.dailab.vsdt.vxl.Vxl".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//// COMPLEX TERMS
	//VxlTerm:
	//	head=VxlElement (operator=VxlOperator tail=VxlTerm)?;
	public VxlTermElements getVxlTermAccess() {
		return pVxlTerm;
	}
	
	public ParserRule getVxlTermRule() {
		return getVxlTermAccess().getRule();
	}

	//VxlElement:
	//	VxlBracketTerm | VxlNegation | VxlMinus | VxlValue | VxlVariable | VxlList | VxlMap | VxlCardinality | VxlFunction |
	//	VxlConstructor;
	public VxlElementElements getVxlElementAccess() {
		return pVxlElement;
	}
	
	public ParserRule getVxlElementRule() {
		return getVxlElementAccess().getRule();
	}

	//// SPECIAL TERMS, UNARY OPERATORS
	//VxlBracketTerm:
	//	"(" term=VxlTerm ")";
	public VxlBracketTermElements getVxlBracketTermAccess() {
		return pVxlBracketTerm;
	}
	
	public ParserRule getVxlBracketTermRule() {
		return getVxlBracketTermAccess().getRule();
	}

	//VxlNegation:
	//	"not" element=VxlElement;
	public VxlNegationElements getVxlNegationAccess() {
		return pVxlNegation;
	}
	
	public ParserRule getVxlNegationRule() {
		return getVxlNegationAccess().getRule();
	}

	//VxlMinus:
	//	"-" element=VxlElement;
	public VxlMinusElements getVxlMinusAccess() {
		return pVxlMinus;
	}
	
	public ParserRule getVxlMinusRule() {
		return getVxlMinusAccess().getRule();
	}

	//VxlCardinality:
	//	"#" element=VxlElement;
	public VxlCardinalityElements getVxlCardinalityAccess() {
		return pVxlCardinality;
	}
	
	public ParserRule getVxlCardinalityRule() {
		return getVxlCardinalityAccess().getRule();
	}

	//// VARIABLES & ACCESSORS
	//VxlVariable:
	//	name=ID accessor=VxlAccessor?;
	public VxlVariableElements getVxlVariableAccess() {
		return pVxlVariable;
	}
	
	public ParserRule getVxlVariableRule() {
		return getVxlVariableAccess().getRule();
	}

	//VxlAccessor:
	//	VxlArrayAccessor | VxlFieldAccessor | VxlMethodAccessor;
	public VxlAccessorElements getVxlAccessorAccess() {
		return pVxlAccessor;
	}
	
	public ParserRule getVxlAccessorRule() {
		return getVxlAccessorAccess().getRule();
	}

	//VxlArrayAccessor:
	//	"[" index=VxlTerm "]" accessor=VxlAccessor?;
	public VxlArrayAccessorElements getVxlArrayAccessorAccess() {
		return pVxlArrayAccessor;
	}
	
	public ParserRule getVxlArrayAccessorRule() {
		return getVxlArrayAccessorAccess().getRule();
	}

	//VxlFieldAccessor:
	//	"." name=ID accessor=VxlAccessor?;
	public VxlFieldAccessorElements getVxlFieldAccessorAccess() {
		return pVxlFieldAccessor;
	}
	
	public ParserRule getVxlFieldAccessorRule() {
		return getVxlFieldAccessorAccess().getRule();
	}

	//VxlMethodAccessor:
	//	"." function=VxlFunction accessor=VxlAccessor?;
	public VxlMethodAccessorElements getVxlMethodAccessorAccess() {
		return pVxlMethodAccessor;
	}
	
	public ParserRule getVxlMethodAccessorRule() {
		return getVxlMethodAccessorAccess().getRule();
	}

	//// LISTS
	//VxlList:
	//	"[" (empty?="]" | body=VxlListElement "]");
	public VxlListElements getVxlListAccess() {
		return pVxlList;
	}
	
	public ParserRule getVxlListRule() {
		return getVxlListAccess().getRule();
	}

	//VxlListElement:
	//	first=VxlTerm ("," rest=VxlListElement)?;
	public VxlListElementElements getVxlListElementAccess() {
		return pVxlListElement;
	}
	
	public ParserRule getVxlListElementRule() {
		return getVxlListElementAccess().getRule();
	}

	//// MAPS
	//VxlMap:
	//	"{" (empty?="}" | body=VxlMapElement "}");
	public VxlMapElements getVxlMapAccess() {
		return pVxlMap;
	}
	
	public ParserRule getVxlMapRule() {
		return getVxlMapAccess().getRule();
	}

	//VxlMapElement:
	//	key=VxlTerm ":" value=VxlTerm ("," rest=VxlMapElement)?;
	public VxlMapElementElements getVxlMapElementAccess() {
		return pVxlMapElement;
	}
	
	public ParserRule getVxlMapElementRule() {
		return getVxlMapElementAccess().getRule();
	}

	//// FUNCTIONS
	//VxlFunction:
	//	name=ID "(" (empty?=")" | body=VxlListElement ")");
	public VxlFunctionElements getVxlFunctionAccess() {
		return pVxlFunction;
	}
	
	public ParserRule getVxlFunctionRule() {
		return getVxlFunctionAccess().getRule();
	}

	//VxlConstructor:
	//	"new" name=FULLY_QUALIFIED "(" (empty?=")" | body=VxlListElement ")");
	public VxlConstructorElements getVxlConstructorAccess() {
		return pVxlConstructor;
	}
	
	public ParserRule getVxlConstructorRule() {
		return getVxlConstructorAccess().getRule();
	}

	//// CONSTANT VALUES
	//VxlValue:
	//	VxlNullConst | VxlBooleanConst | VxlNumericConst | VxlStringConst;
	public VxlValueElements getVxlValueAccess() {
		return pVxlValue;
	}
	
	public ParserRule getVxlValueRule() {
		return getVxlValueAccess().getRule();
	}

	//VxlBooleanConst:
	//	const=('true' | 'false');
	public VxlBooleanConstElements getVxlBooleanConstAccess() {
		return pVxlBooleanConst;
	}
	
	public ParserRule getVxlBooleanConstRule() {
		return getVxlBooleanConstAccess().getRule();
	}

	//VxlNullConst:
	//	const="null";
	public VxlNullConstElements getVxlNullConstAccess() {
		return pVxlNullConst;
	}
	
	public ParserRule getVxlNullConstRule() {
		return getVxlNullConstAccess().getRule();
	}

	//VxlNumericConst:
	//	const=NUMERIC;
	public VxlNumericConstElements getVxlNumericConstAccess() {
		return pVxlNumericConst;
	}
	
	public ParserRule getVxlNumericConstRule() {
		return getVxlNumericConstAccess().getRule();
	}

	//VxlStringConst:
	//	const=STRING;
	public VxlStringConstElements getVxlStringConstAccess() {
		return pVxlStringConst;
	}
	
	public ParserRule getVxlStringConstRule() {
		return getVxlStringConstAccess().getRule();
	}

	//enum VxlOperator:
	//	LT="<" | LE="<=" | EQ="==" | NEQ="!=" | GT=">" | GE=">=" | // Term ** Term -> Bool
	//	ADD="+" | SUB="-" | MULT="*" | DIV="/" | MOD="%" | // Num ** Num -> Num
	//	AND="and" | OR="or" | // Bool ** Bool -> Bool
	//	CONCAT="++";
	public VxlOperatorElements getVxlOperatorAccess() {
		return eVxlOperator;
	}
	
	public EnumRule getVxlOperatorRule() {
		return getVxlOperatorAccess().getRule();
	}

	//// String ** String -> String
	//// NATIVES
	//NUMERIC:
	//	INT ('.' INT)?;
	public NUMERICElements getNUMERICAccess() {
		return pNUMERIC;
	}
	
	public ParserRule getNUMERICRule() {
		return getNUMERICAccess().getRule();
	}

	//FULLY_QUALIFIED:
	//	ID ('.' FULLY_QUALIFIED)?;
	public FULLY_QUALIFIEDElements getFULLY_QUALIFIEDAccess() {
		return pFULLY_QUALIFIED;
	}
	
	public ParserRule getFULLY_QUALIFIEDRule() {
		return getFULLY_QUALIFIEDAccess().getRule();
	}

	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	'/ *'->'* /';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
