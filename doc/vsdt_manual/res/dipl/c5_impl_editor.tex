\chapter{Implementation: The Editor}
\label{chapter:impl_editor}

In this chapter we will introduce the implementation of the BPMN model editor, which is part of the \textsc{Visual Service Design Tool}. The implementation of the mappings to BPEL and JIAC will be introduced in the next chapter.

The editor has been realized as an Eclipse plugin, using the EMF and GMF frameworks, introduced in section \ref{sec:mda_eclipse}. Using these technologies the editor has been specified in a number of models. A large part of the editor code could then be generated from these models, making the implementation as correct as possible and easy to maintain by other developers. Still some customizations were needed to provide all the functionality required for a user-friendly BPMN editor and so all the figures would conform to the graphical notations given in the BPMN specification.

In the following sections we will first describe the rough project structure with its several sub-projects and plugins. Then we will introduce the domain model used for the internal representation of the BPMN elements. After that we will describe how the editor has been specified using GMF and take a look at the customizations that had to be made and the model validation. Finally we will discuss some issues that are not yet fully decided.



\section{Project Structure}

The editor consists of several interdependent plugins (see figure \ref{fig:impl_struc_editor}). In this section we will have a look on their purpose and give a short description for each of them.

\begin{figure}[htp]
	\centering
	\includegraphics[width=.75\textwidth]{figures/impl/struc_editor.png}
	\caption[Editor-Plugin Interdependencies]{Editor-Plugin Interdependencies. Components at the top of the figure require those at the bottom (transitively).}
	\label{fig:impl_struc_editor}
\end{figure}

\begin{itemize}
	\item \texttt{VSDT} This plugin is holding the model implementation as well as the various EMF and GMF model files. This plugin is at the lowest level of the plugin hierarchy. It does in fact provide all that is necessary for programmatically creating, editing and saving BPMN diagrams.
	\item \texttt{VSDT.editor} This plugin is holding the fully generated EMF tree editor. This editor is still necessary for creating and editing some of the non-graphical elements of the models. In the future this editor should be integrated together with the graphical part in a multi page editor.
	\item \texttt{VSDT.edit} This plugin is holding the property item providers used by both the EMF and the GMF editor. The property item providers were first generated by EMF and then customized, e.g. for filtering some of the choices and for enabling property wrappers.
	\item \texttt{VSDT.diagram} This is the main part of the graphical editor.
	\item \texttt{VSDT.figures} This plugin is providing some highly customized helper classes, for instance the figure classes and abstract super classes holding a great deal of the customizations that were needed for the editor parts. They have been removed from the \verb|VSDT.diagram| plugin for simplifying the regeneration of the plugin.
	\item \texttt{VSDT.custom} This plugin is not required for the execution of the editor. However, it provides some custom actions improving the editor's usability and accelerating the execution of some frequently needed editing operations.
\end{itemize}

Since the editor is based on the Graphical Modeling Framework, the GMF plugin is required for the execution as well as all requirements of the GMF plugin.

Eclipse plugins may not have cyclic dependencies. Thus it is necessary to have two customization plugins. The first, \verb|VSDT.figures|, is holding those classes that do not have requirements from the main plugin, \verb|VSDT.diagram|, but which are required by the main plugin. The second, \verb|VSDT.custom| is holding those classes that have dependencies from the main plugin but which are not required by the main plugin. Classes that both have requirements from and are required by the main plugin can not be sourced out of the main plugin.

It might seem reasonable to merge some of the plugins. But remember, that sometimes it is necessary to recreate the diagram plugin from scratch, e.g. when changing to a new major release of GMF. In such a case it will be advantageous not to have the generated classes mixed up with the custom ones.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{The Domain Model}

The BPMN specification is focused on the element's graphical representation, neglecting a formal definition of the data format. It does not provide a XSD file, a class diagram or similar. Instead it only states which attributes the several elements need to have and what these attributes stand for. The rest is left up to the developers of the modeling tools. Thus it is nearly impossible to share BPMN diagrams between editors from different vendors.

The Ecore model has been created with the primary goal to be as close to the specification as possible. Every attribute used in the specification has its representation in the model. The inheritance relationships were derived from the element's attribute lists, which often were said to ``extend'' some other attribute list. However, some of the classes were altered slightly in order to improve the usability of the editor. Figure \ref{fig:model_vsdt} is showing only an extract of the BPMN model since the complete model would be far too large to be shown on a single diagram. The various supporting types are left out as well as the several attribute sets.

\begin{figure}[ht]
	\centering
	\includegraphics[width=1\textwidth]{figures/impl/models/model_vsdt_high.png}
	\caption[The Domain Model]{UML Class Diagram of the editor's domain model (extract). Red: diagram root element; blue: nodes; green: connections; yellow: non-graphical supporting types; orange: attribute sets; white: abstract superclasses}
	\label{fig:model_vsdt}
\end{figure}


\subsection{Containment}

Another problem in creating an Ecore model from the specification was that in an EMF model each element has to be \emph{contained} in some other element (or, in case of the root element, in the resource). Whether a reference on an element should be a \emph{containment reference} is depending on whether the element is ``owned'' by the containing element. In most cases this is clear, like for Lanes being contained in Pools.

For graphical elements the containment structure is constrained by the GMF framework: A node may be contained in a diagram compartment only if the node's domain element is contained in the compartment node's domain element. It would be possible to alter the code in such a way that elements are shown in a different compartment than they are actually contained in, but this is not supported by the GMF tooling, making the generative approach a burden instead of an ease.

An example for this is the case of Processes and Lanes, which has been an open issue for some time. In the specification all the Flow Objects are contained in the Pool's Process but shall be drawn in the Lane's compartment. Thus the containment reference had to be changed so that the Flow Objects are contained in the Lanes. The Process still has a derived reference on the Flow Objects of all the Pool's Lanes.

In other cases, especially for the non-graphical Supporting Types, the containment is not that clear. Messages are referenced by Activities and Events of some type and by Message Flows, whereas both the sending and receiving Flow Object as well as the (optional) Message Flow connecting both of them reference the same Message. Now where should the Message be contained? In this implementation the Message is contained in the Message Flow, if any, or else directly in the Business Process Diagram, the top-level element.


\subsection{Attributes}

Another issue were the numerous sub-type-specific attributes. Activities, Events and Gateways have a specific sub type, e.g. \verb|Send|, \verb|Timer| or \verb|XOR|. All of these sub types require a different set of attributes. Basically there are at least three different ways to provide these attributes:

\begin{enumerate}
	\item create several classes, one for each sub type
	\item provide all the attributes in the base type's class
	\item provide the attributes in separate classes, being referenced by the base type's class
\end{enumerate}

Using the first pattern it would be very complicated to change an elements sub type after creation. In the second pattern, most of the attributes would remain unused and additional audits would be necessary for checking whether every attribute needed for the given sub type is set. In the third pattern the attributes are held in a non-graphical element which has to be synchronized with the element's \verb|type| attribute. The first pattern seems unusable to us. The second and third both have their pros and cons. For now we decided to use the third pattern. Since changing from the third to the second seems a lot easier than the other way round.

Similar to this case there are still some open issues concerning the model. Please refer to section \ref{sec:open_issues} for more.



\section{The Editor Specification}

We decided to use the GMF framework for the implementation of the editor, which has been introduced in \ref{sec:mda_gmf}. Thus the basic editor could be designed easily by setting up a set of models.

However, using GMF brings some restrictions: In order to gain advantage from the generative approach one has to follow the structure and design patterns used by the GMF tooling, making it complicated to customize the editor by hand, since the developers can not transfer all of their expertise from GEF to GMF. Then again, using GMF all the code of each project will be more uniform than code handwritten by several different developers. Thus editors generated with GMF are very well suited for being maintained by large, diverging groups, since everyone familiar with GMF can understand the code.

As said before GMF makes use of a set of models: The \emph{Domain Model}, the \emph{Graphical Definition Model}, the \emph{Tooling Model}, the \emph{Mapping Model} and the \emph{Generator Model}.

\begin{figure}[ht]
	\centering
	\includegraphics[width=1\textwidth]{figures/impl/models/mapmodel.png}
	\caption[VSDT Map Model]{Visualization of the GMF Map Model of the editor (Created with GMF 2.0 M4). Green: Model Elements, Red: Root Element, Edgy-Violet: Child Nodes, Soft-Violet: Node Compartments, Blue: Connections.}
	\label{fig:mapmodel}
\end{figure}

The Domain model used for the \textsc{Visual Service Design Tool} has already been introduced. The Graphical Definition Model for the VSDT, in which the various Nodes and Figures are defined, is making use of a number of custom figures, defined in another plugin. This was necessary because the figures have to be sensitive of the element's state (e.g. its subtype). The Tooling Model consists of only a small number of palette entries. Instead of creating one palette entry for each element or even for each subtype as it can be seen in some other tools we decided to keep the palette clear and concise. The \emph{Create Event} icon is used for Start, End and Intermediate Events, prompting the user which one should be created. Doing so we hope for a good usability. A visualization of the Mapping Model, which glues the other models together and is then used to create the Generator Model, can be seen in figure \ref{fig:mapmodel}.

The Business Process Diagram element has been declared as the root element. The only top level nodes are the three types of Artifacts and the Pools, which again can hold a number of Lanes. The Lanes finally hold the various Flow Objects. One of these, the Activity, is a container, too, and can again hold every Flow Object in its Subprocess Compartment, referencing the nodes defined before. Additionally the Activity Node has a second compartment for holding event handlers, that is, Intermediate Events attached to the Activity's boundary.

Finally, the Generator Model has undergone only minor adjustments, e.g. concerning the file extensions or some layout styles, before it was used for generating the editor code.


\subsection{Customizations}

While the GMF tooling can create a readily usable editor with numerous additional features the generation is still not perfect. Using GMF generated code can be merged with that written by hand, thus bugfixes and missing features can be added to the editor without the risk of nullifying prior changes. %For that purpose the \verb|@generated| tag has to be removed from the Javadoc comment preceding the modified element. Instead of removing the tag it can be more convenient to replace it by some other tag, e.g. \verb|@generated NOT|. This has the advantage that one can search the project files for occurrences of that tag and keep track of all the changes done to the editor.

In this section we will take a look on the several bug fixes and improvements that have been added to the editor.

\begin{itemize}

	\item On each child Edit Part (that is, Edit Parts which's nodes are not drawn directly on the canvas) a extended \verb|GraphicalNodeEditPolicy| has to be installed. This is needed to avoid the duplication of edges drawn between two nested nodes, which is a well-known bug in GMF\footnote{see \url{https://bugs.eclipse.org/bugs/show_bug.cgi?id=148021}} that has been scheduled to be fixed in GMF 2.0 (final). Until then this bugfix is absolutely necessary.
	
	\item When deleting a node from the diagram all the edges going in and out of the node have to be deleted, too. By default, however, only the edge's visualizations are removed from the diagram, while the Connecting Objects remain in the model. To fix this the \verb|VsdtBaseEditHelper| has to implement \verb|getDestroyDependentsCommand|, collecting the connections to be deleted. %Additionally the \verb|getInsteadCommand| method has to regard only the Edit Helper's command in this case. Otherwise the node's Edit Part will return an \verb|UnexecutableCommand|, making the resulting Composite Command unexecutable, too.
	
	\item To support the reorienting of connections, the connections' Edit Helpers have to implement the \verb|getReorientRelationshipCommand| method.
	
	\item Each of the Item Providers inherit from an extended \verb|ItemProviderAdapter|, providing the Item Providers with special \verb|ItemPropertyDescriptor|s, wrapping EObject property values. This way referenced model elements can be expanded in the property view. Otherwise the user would have to use the EMF editor whenever he'd want to edit some non-graphical element's values.
	
	\item The \verb|ModelingAssistantProvider| has been customized to enable connection handles and to rearrange the elements in the popup menus.
	
	\item The Edit Parts extend some abstract Edit Part holding most of the customizations. This way the customizations are clearly arranged and in some cases can be reused for more than one Edit Part. %Typically these abstract Edit Parts initialize the Edit Part's figure according to the element's attributes, e.g. the sub type, and implement the \verb|notifyChanged| method to react to model changes.
	
	\item Each of the figures is heavily customized. This is necessary since most figures have to adapt to the underlying model element's sub type and other attributes, enabling and disabling various markers on the figure. %Most customizations were necessary for the \verb|ActivityFigure|, which not only has markers for various attributes but also two compartments.
	
	%\item Alongside with the activity figure also the Activity's compartment figures had to be customized to conform to the visualization given in the BPMN specification.
	
	\item The validation audits (see section \ref{sec:validation}) have been implemented in Java. To avoid conflicts or unwanted dispose of implementations when the diagram editor is regenerated they have been moved to a separate class outside of the constantly regenerated main project.
	
	\item The \verb|VSDT.custom| project contains some custom actions. These actions can be reached via the editor's context menus and provide some shortcuts for editing operations that would otherwise be very time consuming or error prone. However, this project is not needed for the editor to work.

\end{itemize}

Beside the diagram editor the model implementation has been enriched with many additional methods. We will not enumerate every single change here but only state the categories of additions.

\begin{itemize}

	\item Some customizations are used to instantiate non-graphical elements. For instance when an Activity's type is set to a new value an Attribute Set for that type will be created and bound to the Activity. Further Expressions and IDs are instantiated on the creation of their parent element. Otherwise the EMF tree editor would have to be used for creating those elements.
	
	\item Some custom methods are frequently needed shortcuts, e.g. for getting a Flow Object's Process by going all the way up to the Pool and from there to the Process, or to determine whether some element is the first in a Sequence or if an Intermediate Event is in normal flow.
	
	\item Custom methods are used for the synchronization of associated model elements. For example whenever an outgoing Sequence Flow is connected to a Gateway a new instance of the non-graphical element \verb|Gate| is created, associated with the Sequence Flow and added to the Gateway (analogue when the Sequence Flow is removed or redirected).
	
	\item The custom actions mentioned earlier are using custom undoable methods in the model implementation, for instance for initializing a Pool's Participant and other editing operations that can be automated. Due to the EMF framework these methods can be undone with no need for additional undo and redo methods.

\end{itemize}

While some of these customizations, like the custom actions, are intended to improve the editor's usability, most are needed to avoid unwanted behavior in certain situations or for the further adjustment of the editor to BPMN, for instance by providing a number of additional audits, which will be the topic of the next section.


\subsection{Validation}
\label{sec:validation}

As mentioned before, the GMF provides an easy way to validate models created with the editor. This way illegal models and model elements can be identified. The validation consists of two parts.

\begin{itemize}
	\item basic validation of multiplicities provided by \emph{EMFT Validation}
	\item custom GMF validation
\end{itemize}

Using the \emph{EMFT Validation Project} the editor is capable of validating the various model elements to conform to the minimum and maximum multiplicities given in the Ecore model. This is very useful since it excuses the programmer from implementing this simple but extensive validation by hand.

In cases a multiplicity is dependent on another attribute or another aspect of the element's context, for instance when either attribute \verb|a| \emph{or} attribute \verb|b| is required (or allowed) to have a value, but not both, a custom audit can be defined in the GMF mapping model. These audits are then tested automatically for each instance of the type specified in the audit's definition.

Both the Object Constraint Language (OCL) \cite{spec_ocl} and Java can be used as validation language and attributes can be validated using regular expressions, too. In this implementation in most cases Java has been chosen as validation language since it does provide much better debugging and should be faster, too, since those checks do not have to be interpreted by an OCL parser first. On the downside Java constraints have to be implemented in the generated code while OCL constraints can be specified directly in the mapping model.

Currently there are about 60 audits used in the editor. The audits were derived from constraint that are given throughout the BPMN specification. The Java methods representing the audits are named as ``[modelElement][nr][description]''. For instance, the audit \verb|Boolean start4messageFlowHasMessageTrigger(Start self)| is the fourth audit for the Start Event element; it checks whether a Start Event with an incoming Message Flow has a trigger of type Message and returns \verb|TRUE| or \verb|FALSE| accordingly.

The model can be validated on-the-fly or on demand. If there are any errors or other problems found the node or edge corresponding to the erroneous model element as well as the resource holding the element can be given an error marker. The error is listed in the Eclipse \emph{Problem View} and the description is given as a tool tip when hovering the mouse over the error marker.



\section{Open Issues}
\label{sec:open_issues}

As mentioned earlier there are still some open issues, especially concerning the model. Each of the alternatives have their pros and cons. However, the final decision on these topics has been postponed for now.


\subsection{Attribute Sets}

Depending on its \verb|type| each Flow Object -- Events, Activities and Gateways -- needs different attributes. These are the possibilities to handle these type specific attributes:

\begin{itemize}
        \item Define a separate class for each of these subtypes. This has the disadvantage that there will be many different classes -- especially for the Events with their second subtype, \verb|Start|, \verb|End| and \verb|Intermediate|. Furthermore it would not be possible to change a node's type afterwards and it would require a lot of code duplication.
        \item Put all these attributes in the base class. This approach would require additional audits to decide if all the attributes required for the given type are set, since the attribute's multiplicity is depending on the subtype and can not be validated by the built-in EMF validation feature. Further the property view would have to be configured to show only those attributes relevant for the subtype, which is currently not provided by GMF.
        \item Create a class for each set of attributes, being referenced by the base type's class. Thus it is possible to use the built-in multiplicity validator while preserving the ability to change the subtype. In the property view the \verb|AttributeSet| -- as well as every other EReference -- can be wrapped, so it can be expanded and the attributes can be set in the graphical editor, although they are held in a non-graphical element (see figure \ref{fig:attSet}). On the downside the \verb|AttributeSet| has to be synchronized with the \verb|type| attribute, which can be done using the \verb|EditPart|'s \verb|notifyChanged| method or the model element's implementation's \verb|setType| method.
\end{itemize}

\begin{figure}[ht]
	\centering
	\includegraphics[width=.75\textwidth]{figures/screens/attSet.png}
	\caption[Attribute Set in Eclipse Property View]{Property View with expanded Attribute Set wrapper.}
	\label{fig:attSet}
\end{figure}

Currently the AttributeSet approach is being used. It might seem to be redundant using the \verb|type| attribute as well as the AttributeSets. But other than the AttributeSet to be used the type can be selected from a drop down list in the property view, which will then initialize the AttributeSet.

Whenever reading one of the subtype's attributes the referenced AttributeSet has to be casted to its real type. This approach does require some code duplication, since some subtypes, like \verb|Send| and \verb|Receive| Tasks, have common attributes. This could be improved by introducing additional AttributeSets holding the common attributes acting as a super class for the actual AttributeSets.

Despite the fact that it would require a number of additional audits, putting all the attributes in the base class might be reasonable, too. There would be no need for class castings, making the code much more readable. However, this is not practicable until finding a way to dynamically filter the editor's property sources according to the sub type. The generated property item providers follow the Singleton pattern, so there is only one instance of the item provider for each element of the same type. Providing a dynamically changing property provider would require serious customization of the editor's generated structures.


\subsection{Expressions}

Numerous BPMN element types have one or more attributes of type \verb|Expression|. In the specification an Expression is not more than a wrapper for a String, holding the actual expression. We are not yet fully decided how to handle the Expression type.

\begin{itemize}
        \item Keep close to the specification and use the \verb|Expression| type. This way the Expression class could provide methods for validating the expression, or expressions could even be edited in a separate editor, providing features like syntax highlighting. 
        \item Dissolve the Expression type and use simple Strings instead.
\end{itemize}

None of the advantages of using a special Expression class are currently used. The expressions can not be validated or evaluated, since the expression language to be used is unknown at the editor's design time. Of course one could arbitrarily provide validators for several expression languages, like Java, JADL or XPath. Maybe these validator could even be provided together with an export wizard requiring expressions to be written in that language.

However, by now all these are not more than ideas.

On the downside using the Expression type is currently complicating entering expressions: The Expression type has to be expanded to edit the \emph{expression in the Expression}. Using plain Strings the expressions could be easier edited in the property view using the standard String property provider.

So it might be reasonable to dissolve the Expression type and use simple Strings for now. However, dissolving the Expression type will be much easier than restoring it. Thus we will keep it for now.

Of course the best way would be finding a way to use the standard String property provider to edit the expression String wrapped in the Expression instance without expanding it in the property view.


\subsection{Tasks and Subprocesses}

We decided to use the type Activity for both Tasks and Subprocesses, so the user is free to expand a Task to a Subprocess. However, in the BPMN specification as well as in many other BPMN editors individual graphical elements are used for Tasks and Subprocesses.

\begin{itemize}
        \item Represent both Tasks and Subprocesses with the Activity type. This has the advantage that the user can easily change from Task to Subprocess without deleting and recreating the element.
        \item Use different types for Tasks and Subprocesses. This is closer to the specification and has the advantage that the user is not confused with attributes relevant for Subprocesses only when dealing with Tasks and vice versa.
\end{itemize}

The use of the Activity type for both Tasks and Subprocesses has some clear advantages, like being able to switch from some Task type to a Subprocess type. However, using separate types for Tasks and Subprocesses would result in better icons for both. Using the same figure for both means that Tasks have a Subprocess compartment, too, making the figure unnecessarily larger. It is possible to reduce the compartment's size when the type is different from \verb|Embedded|, which is the only activity type that actually used the compartment. But this demands the user to set the Activity's type to \verb|Embedded| before inserting any child elements, and when changing the type to something else than \verb|Embedded| the Subprocess compartment might be minimized with the elements still inside of it. The user would have to expand it again to remove those elements.

Using only one type and figure for both Tasks and Subprocesses seems be the best choice, but the Activity figure might need some improvement to fit all the needs.
\\
\\

In this chapter the BPMN editor that is part of the \textsc{Visual Service Design Tool} has been introduced. We have explained the domain model, how GMF was used for the editor's generation and how it was extended with a number of custom features to improve its usability.

The next chapter will introduce the implementation of the transformation tool used for the mapping from BPMN to JIAC and BPEL.