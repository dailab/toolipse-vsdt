/*
* generated by Xtext
*/
package de.dailab.vsdt.vxl.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import de.dailab.vsdt.vxl.services.VxlGrammarAccess;

import com.google.inject.Inject;

public class VxlParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private VxlGrammarAccess grammarAccess;
		
	public VxlGrammarAccess getGrammarAccess() {
		return grammarAccess;
	}

	protected AbstractToken getRootToken(IInstanceDescription inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IInstanceDescription inst) {
		super(inst);
	}
	
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlTerm_Group(this, this, 0, inst);
			case 1: return new VxlHead_Alternatives(this, this, 1, inst);
			case 2: return new VxlTail_Group(this, this, 2, inst);
			case 3: return new VxlBracketTerm_Group(this, this, 3, inst);
			case 4: return new VxlNegation_Group(this, this, 4, inst);
			case 5: return new VxlMinus_Group(this, this, 5, inst);
			case 6: return new VxlAtom_Alternatives(this, this, 6, inst);
			case 7: return new VxlVariable_Group(this, this, 7, inst);
			case 8: return new VxlAccessor_Alternatives(this, this, 8, inst);
			case 9: return new VxlArrayAccessor_Group(this, this, 9, inst);
			case 10: return new VxlFieldAccessor_Group(this, this, 10, inst);
			case 11: return new VxlList_Group(this, this, 11, inst);
			case 12: return new VxlListElement_Group(this, this, 12, inst);
			case 13: return new VxlValue_Alternatives(this, this, 13, inst);
			case 14: return new VxlStringConst_ConstAssignment(this, this, 14, inst);
			case 15: return new VxlNumericConst_ConstAssignment(this, this, 15, inst);
			case 16: return new VxlBooleanConst_ConstAssignment(this, this, 16, inst);
			case 17: return new VxlNullConst_ConstAssignment(this, this, 17, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule VxlTerm ****************
 *
 * VxlTerm:
 *   head=VxlHead tail=VxlTail?; 
 * 
 * // COMPLEX TERMS
 *
 **/

// head=VxlHead tail=VxlTail?
protected class VxlTerm_Group extends GroupToken {
	
	public VxlTerm_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getVxlTermAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlTerm_TailAssignment_1(parent, this, 0, inst);
			case 1: return new VxlTerm_HeadAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getVxlTermRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// head=VxlHead
protected class VxlTerm_HeadAssignment_0 extends AssignmentToken  {
	
	public VxlTerm_HeadAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getVxlTermAccess().getHeadAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlHead_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("head",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("head");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getVxlHeadRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getVxlTermAccess().getHeadVxlHeadParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// tail=VxlTail?
protected class VxlTerm_TailAssignment_1 extends AssignmentToken  {
	
	public VxlTerm_TailAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getVxlTermAccess().getTailAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlTail_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("tail",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("tail");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getVxlTailRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getVxlTermAccess().getTailVxlTailParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new VxlTerm_HeadAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule VxlTerm ****************/


/************ begin Rule VxlHead ****************
 *
 * VxlHead:
 *   VxlBracketTerm|VxlNegation|VxlMinus|VxlAtom;
 *
 **/

// VxlBracketTerm|VxlNegation|VxlMinus|VxlAtom
protected class VxlHead_Alternatives extends AlternativesToken {

	public VxlHead_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getVxlHeadAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlHead_VxlBracketTermParserRuleCall_0(parent, this, 0, inst);
			case 1: return new VxlHead_VxlNegationParserRuleCall_1(parent, this, 1, inst);
			case 2: return new VxlHead_VxlMinusParserRuleCall_2(parent, this, 2, inst);
			case 3: return new VxlHead_VxlAtomParserRuleCall_3(parent, this, 3, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getVxlHeadRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// VxlBracketTerm
protected class VxlHead_VxlBracketTermParserRuleCall_0 extends RuleCallToken {
	
	public VxlHead_VxlBracketTermParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getVxlHeadAccess().getVxlBracketTermParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlBracketTerm_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(VxlBracketTerm_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getVxlBracketTermRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// VxlNegation
protected class VxlHead_VxlNegationParserRuleCall_1 extends RuleCallToken {
	
	public VxlHead_VxlNegationParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getVxlHeadAccess().getVxlNegationParserRuleCall_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlNegation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(VxlNegation_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getVxlNegationRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// VxlMinus
protected class VxlHead_VxlMinusParserRuleCall_2 extends RuleCallToken {
	
	public VxlHead_VxlMinusParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getVxlHeadAccess().getVxlMinusParserRuleCall_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlMinus_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(VxlMinus_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getVxlMinusRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// VxlAtom
protected class VxlHead_VxlAtomParserRuleCall_3 extends RuleCallToken {
	
	public VxlHead_VxlAtomParserRuleCall_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getVxlHeadAccess().getVxlAtomParserRuleCall_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlAtom_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(VxlAtom_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getVxlAtomRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule VxlHead ****************/


/************ begin Rule VxlTail ****************
 *
 * VxlTail:
 *   operator=VxlOperator term=VxlTerm;
 *
 **/

// operator=VxlOperator term=VxlTerm
protected class VxlTail_Group extends GroupToken {
	
	public VxlTail_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getVxlTailAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlTail_TermAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getVxlTailRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// operator=VxlOperator
protected class VxlTail_OperatorAssignment_0 extends AssignmentToken  {
	
	public VxlTail_OperatorAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getVxlTailAccess().getOperatorAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getVxlTailAccess().getOperatorVxlOperatorEnumRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// term=VxlTerm
protected class VxlTail_TermAssignment_1 extends AssignmentToken  {
	
	public VxlTail_TermAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getVxlTailAccess().getTermAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlTerm_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("term",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("term");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getVxlTermRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getVxlTailAccess().getTermVxlTermParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new VxlTail_OperatorAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule VxlTail ****************/


/************ begin Rule VxlBracketTerm ****************
 *
 * VxlBracketTerm:
 *   "(" term=VxlTerm ")";
 *
 **/

// "(" term=VxlTerm ")"
protected class VxlBracketTerm_Group extends GroupToken {
	
	public VxlBracketTerm_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getVxlBracketTermAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlBracketTerm_RightParenthesisKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getVxlBracketTermRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "("
protected class VxlBracketTerm_LeftParenthesisKeyword_0 extends KeywordToken  {
	
	public VxlBracketTerm_LeftParenthesisKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getVxlBracketTermAccess().getLeftParenthesisKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// term=VxlTerm
protected class VxlBracketTerm_TermAssignment_1 extends AssignmentToken  {
	
	public VxlBracketTerm_TermAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getVxlBracketTermAccess().getTermAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlTerm_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("term",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("term");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getVxlTermRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getVxlBracketTermAccess().getTermVxlTermParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new VxlBracketTerm_LeftParenthesisKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class VxlBracketTerm_RightParenthesisKeyword_2 extends KeywordToken  {
	
	public VxlBracketTerm_RightParenthesisKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getVxlBracketTermAccess().getRightParenthesisKeyword_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlBracketTerm_TermAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule VxlBracketTerm ****************/


/************ begin Rule VxlNegation ****************
 *
 * VxlNegation:
 *   "not" head=VxlHead;
 *
 **/

// "not" head=VxlHead
protected class VxlNegation_Group extends GroupToken {
	
	public VxlNegation_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getVxlNegationAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlNegation_HeadAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getVxlNegationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "not"
protected class VxlNegation_NotKeyword_0 extends KeywordToken  {
	
	public VxlNegation_NotKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getVxlNegationAccess().getNotKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// head=VxlHead
protected class VxlNegation_HeadAssignment_1 extends AssignmentToken  {
	
	public VxlNegation_HeadAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getVxlNegationAccess().getHeadAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlHead_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("head",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("head");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getVxlHeadRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getVxlNegationAccess().getHeadVxlHeadParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new VxlNegation_NotKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule VxlNegation ****************/


/************ begin Rule VxlMinus ****************
 *
 * VxlMinus:
 *   "-" head=VxlHead;
 *
 **/

// "-" head=VxlHead
protected class VxlMinus_Group extends GroupToken {
	
	public VxlMinus_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getVxlMinusAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlMinus_HeadAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getVxlMinusRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "-"
protected class VxlMinus_HyphenMinusKeyword_0 extends KeywordToken  {
	
	public VxlMinus_HyphenMinusKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getVxlMinusAccess().getHyphenMinusKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// head=VxlHead
protected class VxlMinus_HeadAssignment_1 extends AssignmentToken  {
	
	public VxlMinus_HeadAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getVxlMinusAccess().getHeadAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlHead_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("head",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("head");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getVxlHeadRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getVxlMinusAccess().getHeadVxlHeadParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new VxlMinus_HyphenMinusKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule VxlMinus ****************/


/************ begin Rule VxlAtom ****************
 *
 * VxlAtom:
 *   VxlValue|VxlVariable|VxlList; 
 * 			         
 * 
 * // VARIABLES & ACCESSORS
 *
 **/

// VxlValue|VxlVariable|VxlList 
// 			         
// 
// // VARIABLES & ACCESSORS
protected class VxlAtom_Alternatives extends AlternativesToken {

	public VxlAtom_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getVxlAtomAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlAtom_VxlValueParserRuleCall_0(parent, this, 0, inst);
			case 1: return new VxlAtom_VxlVariableParserRuleCall_1(parent, this, 1, inst);
			case 2: return new VxlAtom_VxlListParserRuleCall_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getVxlAtomRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// VxlValue
protected class VxlAtom_VxlValueParserRuleCall_0 extends RuleCallToken {
	
	public VxlAtom_VxlValueParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getVxlAtomAccess().getVxlValueParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlValue_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(VxlValue_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getVxlValueRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// VxlVariable
protected class VxlAtom_VxlVariableParserRuleCall_1 extends RuleCallToken {
	
	public VxlAtom_VxlVariableParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getVxlAtomAccess().getVxlVariableParserRuleCall_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlVariable_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(VxlVariable_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getVxlVariableRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// VxlList
protected class VxlAtom_VxlListParserRuleCall_2 extends RuleCallToken {
	
	public VxlAtom_VxlListParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getVxlAtomAccess().getVxlListParserRuleCall_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlList_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(VxlList_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getVxlListRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule VxlAtom ****************/


/************ begin Rule VxlVariable ****************
 *
 * VxlVariable:
 *   name=ID accessor=VxlAccessor?; 
 * 
 * // VARIABLES & ACCESSORS
 *
 **/

// name=ID accessor=VxlAccessor?
protected class VxlVariable_Group extends GroupToken {
	
	public VxlVariable_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getVxlVariableAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlVariable_AccessorAssignment_1(parent, this, 0, inst);
			case 1: return new VxlVariable_NameAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getVxlVariableRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// name=ID
protected class VxlVariable_NameAssignment_0 extends AssignmentToken  {
	
	public VxlVariable_NameAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getVxlVariableAccess().getNameAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getVxlVariableAccess().getNameIDTerminalRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// accessor=VxlAccessor?
protected class VxlVariable_AccessorAssignment_1 extends AssignmentToken  {
	
	public VxlVariable_AccessorAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getVxlVariableAccess().getAccessorAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlAccessor_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("accessor",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("accessor");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getVxlAccessorRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getVxlVariableAccess().getAccessorVxlAccessorParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new VxlVariable_NameAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule VxlVariable ****************/


/************ begin Rule VxlAccessor ****************
 *
 * VxlAccessor:
 *   VxlArrayAccessor|VxlFieldAccessor;
 *
 **/

// VxlArrayAccessor|VxlFieldAccessor
protected class VxlAccessor_Alternatives extends AlternativesToken {

	public VxlAccessor_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getVxlAccessorAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlAccessor_VxlArrayAccessorParserRuleCall_0(parent, this, 0, inst);
			case 1: return new VxlAccessor_VxlFieldAccessorParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getVxlAccessorRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// VxlArrayAccessor
protected class VxlAccessor_VxlArrayAccessorParserRuleCall_0 extends RuleCallToken {
	
	public VxlAccessor_VxlArrayAccessorParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getVxlAccessorAccess().getVxlArrayAccessorParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlArrayAccessor_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(VxlArrayAccessor_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getVxlArrayAccessorRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// VxlFieldAccessor
protected class VxlAccessor_VxlFieldAccessorParserRuleCall_1 extends RuleCallToken {
	
	public VxlAccessor_VxlFieldAccessorParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getVxlAccessorAccess().getVxlFieldAccessorParserRuleCall_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlFieldAccessor_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(VxlFieldAccessor_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getVxlFieldAccessorRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule VxlAccessor ****************/


/************ begin Rule VxlArrayAccessor ****************
 *
 * VxlArrayAccessor:
 *   "[" index=VxlTerm "]" accessor=VxlAccessor?;
 *
 **/

// "[" index=VxlTerm "]" accessor=VxlAccessor?
protected class VxlArrayAccessor_Group extends GroupToken {
	
	public VxlArrayAccessor_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getVxlArrayAccessorAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlArrayAccessor_AccessorAssignment_3(parent, this, 0, inst);
			case 1: return new VxlArrayAccessor_RightSquareBracketKeyword_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getVxlArrayAccessorRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "["
protected class VxlArrayAccessor_LeftSquareBracketKeyword_0 extends KeywordToken  {
	
	public VxlArrayAccessor_LeftSquareBracketKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getVxlArrayAccessorAccess().getLeftSquareBracketKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// index=VxlTerm
protected class VxlArrayAccessor_IndexAssignment_1 extends AssignmentToken  {
	
	public VxlArrayAccessor_IndexAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getVxlArrayAccessorAccess().getIndexAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlTerm_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("index",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("index");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getVxlTermRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getVxlArrayAccessorAccess().getIndexVxlTermParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new VxlArrayAccessor_LeftSquareBracketKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "]"
protected class VxlArrayAccessor_RightSquareBracketKeyword_2 extends KeywordToken  {
	
	public VxlArrayAccessor_RightSquareBracketKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getVxlArrayAccessorAccess().getRightSquareBracketKeyword_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlArrayAccessor_IndexAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// accessor=VxlAccessor?
protected class VxlArrayAccessor_AccessorAssignment_3 extends AssignmentToken  {
	
	public VxlArrayAccessor_AccessorAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getVxlArrayAccessorAccess().getAccessorAssignment_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlAccessor_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("accessor",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("accessor");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getVxlAccessorRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getVxlArrayAccessorAccess().getAccessorVxlAccessorParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new VxlArrayAccessor_RightSquareBracketKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule VxlArrayAccessor ****************/


/************ begin Rule VxlFieldAccessor ****************
 *
 * VxlFieldAccessor:
 *   "." name=ID accessor=VxlAccessor?; 
 * 	             
 * 
 * // LISTS
 *
 **/

// "." name=ID accessor=VxlAccessor?
protected class VxlFieldAccessor_Group extends GroupToken {
	
	public VxlFieldAccessor_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getVxlFieldAccessorAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlFieldAccessor_AccessorAssignment_2(parent, this, 0, inst);
			case 1: return new VxlFieldAccessor_NameAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getVxlFieldAccessorRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "."
protected class VxlFieldAccessor_FullStopKeyword_0 extends KeywordToken  {
	
	public VxlFieldAccessor_FullStopKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getVxlFieldAccessorAccess().getFullStopKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// name=ID
protected class VxlFieldAccessor_NameAssignment_1 extends AssignmentToken  {
	
	public VxlFieldAccessor_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getVxlFieldAccessorAccess().getNameAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlFieldAccessor_FullStopKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getVxlFieldAccessorAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// accessor=VxlAccessor?
protected class VxlFieldAccessor_AccessorAssignment_2 extends AssignmentToken  {
	
	public VxlFieldAccessor_AccessorAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getVxlFieldAccessorAccess().getAccessorAssignment_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlAccessor_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("accessor",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("accessor");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getVxlAccessorRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getVxlFieldAccessorAccess().getAccessorVxlAccessorParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new VxlFieldAccessor_NameAssignment_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule VxlFieldAccessor ****************/


/************ begin Rule VxlList ****************
 *
 * VxlList:
 *   "[" body=VxlListElement? "]"; 
 * 
 * // LISTS
 *
 **/

// "[" body=VxlListElement? "]"
protected class VxlList_Group extends GroupToken {
	
	public VxlList_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getVxlListAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlList_RightSquareBracketKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getVxlListRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "["
protected class VxlList_LeftSquareBracketKeyword_0 extends KeywordToken  {
	
	public VxlList_LeftSquareBracketKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getVxlListAccess().getLeftSquareBracketKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// body=VxlListElement?
protected class VxlList_BodyAssignment_1 extends AssignmentToken  {
	
	public VxlList_BodyAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getVxlListAccess().getBodyAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlListElement_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("body",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("body");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getVxlListElementRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getVxlListAccess().getBodyVxlListElementParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new VxlList_LeftSquareBracketKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "]"
protected class VxlList_RightSquareBracketKeyword_2 extends KeywordToken  {
	
	public VxlList_RightSquareBracketKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getVxlListAccess().getRightSquareBracketKeyword_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlList_BodyAssignment_1(parent, this, 0, inst);
			case 1: return new VxlList_LeftSquareBracketKeyword_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule VxlList ****************/


/************ begin Rule VxlListElement ****************
 *
 * VxlListElement:
 *   first=VxlTerm ("," rest=VxlListElement)?;  
 * 		             
 * 
 * // CONSTANTS
 *
 **/

// first=VxlTerm ("," rest=VxlListElement)?
protected class VxlListElement_Group extends GroupToken {
	
	public VxlListElement_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getVxlListElementAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlListElement_Group_1(parent, this, 0, inst);
			case 1: return new VxlListElement_FirstAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getVxlListElementRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// first=VxlTerm
protected class VxlListElement_FirstAssignment_0 extends AssignmentToken  {
	
	public VxlListElement_FirstAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getVxlListElementAccess().getFirstAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlTerm_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("first",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("first");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getVxlTermRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getVxlListElementAccess().getFirstVxlTermParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// ("," rest=VxlListElement)?
protected class VxlListElement_Group_1 extends GroupToken {
	
	public VxlListElement_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getVxlListElementAccess().getGroup_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlListElement_RestAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class VxlListElement_CommaKeyword_1_0 extends KeywordToken  {
	
	public VxlListElement_CommaKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getVxlListElementAccess().getCommaKeyword_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlListElement_FirstAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// rest=VxlListElement
protected class VxlListElement_RestAssignment_1_1 extends AssignmentToken  {
	
	public VxlListElement_RestAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getVxlListElementAccess().getRestAssignment_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlListElement_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("rest",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rest");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getVxlListElementRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getVxlListElementAccess().getRestVxlListElementParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new VxlListElement_CommaKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule VxlListElement ****************/


/************ begin Rule VxlValue ****************
 *
 * VxlValue:
 *   VxlStringConst|VxlBooleanConst|VxlNumericConst|VxlNullConst; 
 * 
 * // CONSTANTS
 *
 **/

// VxlStringConst|VxlBooleanConst|VxlNumericConst|VxlNullConst 
// 
// // CONSTANTS
protected class VxlValue_Alternatives extends AlternativesToken {

	public VxlValue_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getVxlValueAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlValue_VxlStringConstParserRuleCall_0(parent, this, 0, inst);
			case 1: return new VxlValue_VxlBooleanConstParserRuleCall_1(parent, this, 1, inst);
			case 2: return new VxlValue_VxlNumericConstParserRuleCall_2(parent, this, 2, inst);
			case 3: return new VxlValue_VxlNullConstParserRuleCall_3(parent, this, 3, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getVxlValueRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// VxlStringConst
protected class VxlValue_VxlStringConstParserRuleCall_0 extends RuleCallToken {
	
	public VxlValue_VxlStringConstParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getVxlValueAccess().getVxlStringConstParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlStringConst_ConstAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(VxlStringConst_ConstAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getVxlStringConstRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// VxlBooleanConst
protected class VxlValue_VxlBooleanConstParserRuleCall_1 extends RuleCallToken {
	
	public VxlValue_VxlBooleanConstParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getVxlValueAccess().getVxlBooleanConstParserRuleCall_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlBooleanConst_ConstAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(VxlBooleanConst_ConstAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getVxlBooleanConstRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// VxlNumericConst
protected class VxlValue_VxlNumericConstParserRuleCall_2 extends RuleCallToken {
	
	public VxlValue_VxlNumericConstParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getVxlValueAccess().getVxlNumericConstParserRuleCall_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlNumericConst_ConstAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(VxlNumericConst_ConstAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getVxlNumericConstRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// VxlNullConst
protected class VxlValue_VxlNullConstParserRuleCall_3 extends RuleCallToken {
	
	public VxlValue_VxlNullConstParserRuleCall_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getVxlValueAccess().getVxlNullConstParserRuleCall_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VxlNullConst_ConstAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(VxlNullConst_ConstAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getVxlNullConstRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule VxlValue ****************/


/************ begin Rule VxlStringConst ****************
 *
 * VxlStringConst:
 *   const=STRING; 
 * 		     
 * //NumericConst:		const = INT; // keine kommazahlen
 *
 **/

// const=STRING
protected class VxlStringConst_ConstAssignment extends AssignmentToken  {
	
	public VxlStringConst_ConstAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getVxlStringConstAccess().getConstAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getVxlStringConstRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("const",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("const");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getVxlStringConstAccess().getConstSTRINGTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule VxlStringConst ****************/


/************ begin Rule VxlNumericConst ****************
 *
 * VxlNumericConst:
 *   const=NUMERIC; 
 * //NumericConst:		const = INT; // keine kommazahlen 
 * 	     
 * // BooleanConst:	isTrue ?= "true" | "false";
 *
 **/

// const=NUMERIC
protected class VxlNumericConst_ConstAssignment extends AssignmentToken  {
	
	public VxlNumericConst_ConstAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getVxlNumericConstAccess().getConstAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getVxlNumericConstRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("const",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("const");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getVxlNumericConstAccess().getConstNUMERICParserRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule VxlNumericConst ****************/


/************ begin Rule VxlBooleanConst ****************
 *
 * VxlBooleanConst:
 *   const=( "true" | "false" ); 
 * // BooleanConst:	isTrue ?= "true" | "false";
 *
 **/

// const=( "true" | "false" )
protected class VxlBooleanConst_ConstAssignment extends AssignmentToken  {
	
	public VxlBooleanConst_ConstAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getVxlBooleanConstAccess().getConstAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getVxlBooleanConstRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("const",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("const");
		if("true".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getVxlBooleanConstAccess().getConstTrueKeyword_0_0();
			return obj;
		}
		if("false".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getVxlBooleanConstAccess().getConstFalseKeyword_0_1();
			return obj;
		}
		return null;
	}

}

/************ end Rule VxlBooleanConst ****************/


/************ begin Rule VxlNullConst ****************
 *
 * VxlNullConst:
 *   const="null"; 
 * 		     
 * 
 * // OPERATIONS
 *
 **/

// const="null"
protected class VxlNullConst_ConstAssignment extends AssignmentToken  {
	
	public VxlNullConst_ConstAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getVxlNullConstAccess().getConstAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getVxlNullConstRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("const",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("const");
		if("null".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getVxlNullConstAccess().getConstNullKeyword_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule VxlNullConst ****************/


}
