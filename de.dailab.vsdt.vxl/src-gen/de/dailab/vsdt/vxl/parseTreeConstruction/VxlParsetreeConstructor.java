/*
* generated by Xtext
*/
package de.dailab.vsdt.vxl.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import de.dailab.vsdt.vxl.services.VxlGrammarAccess;

import com.google.inject.Inject;

public class VxlParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private VxlGrammarAccess grammarAccess;
		
	public VxlGrammarAccess getGrammarAccess() {
		return grammarAccess;
	}

	protected AbstractToken getRootToken(IInstanceDescription inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IInstanceDescription inst) {
		super(inst);
	}
	
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Term_Group(this, this, 0, inst);
			case 1: return new Head_Alternatives(this, this, 1, inst);
			case 2: return new Tail_Group(this, this, 2, inst);
			case 3: return new BracketTerm_Group(this, this, 3, inst);
			case 4: return new Negation_Group(this, this, 4, inst);
			case 5: return new Minus_Group(this, this, 5, inst);
			case 6: return new Atom_Alternatives(this, this, 6, inst);
			case 7: return new Variable_Group(this, this, 7, inst);
			case 8: return new Accessor_Alternatives(this, this, 8, inst);
			case 9: return new ArrayAccessor_Group(this, this, 9, inst);
			case 10: return new FieldAccessor_Group(this, this, 10, inst);
			case 11: return new Value_Alternatives(this, this, 11, inst);
			case 12: return new StringConst_ConstAssignment(this, this, 12, inst);
			case 13: return new NumericConst_ConstAssignment(this, this, 13, inst);
			case 14: return new BooleanConst_ConstAssignment(this, this, 14, inst);
			case 15: return new NullConst_ConstAssignment(this, this, 15, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule Term ****************
 *
 * Term:
 *   head=Head tail=Tail?; 
 * 
 * // COMPLEX TERMS
 *
 **/

// head=Head tail=Tail?
protected class Term_Group extends GroupToken {
	
	public Term_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getTermAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Term_TailAssignment_1(parent, this, 0, inst);
			case 1: return new Term_HeadAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTermRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// head=Head
protected class Term_HeadAssignment_0 extends AssignmentToken  {
	
	public Term_HeadAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getTermAccess().getHeadAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Head_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("head",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("head");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getHeadRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTermAccess().getHeadHeadParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// tail=Tail?
protected class Term_TailAssignment_1 extends AssignmentToken  {
	
	public Term_TailAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getTermAccess().getTailAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Tail_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("tail",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("tail");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTailRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTermAccess().getTailTailParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Term_HeadAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Term ****************/


/************ begin Rule Head ****************
 *
 * Head:
 *   BracketTerm|Negation|Minus|Atom;
 *
 **/

// BracketTerm|Negation|Minus|Atom
protected class Head_Alternatives extends AlternativesToken {

	public Head_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getHeadAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Head_BracketTermParserRuleCall_0(parent, this, 0, inst);
			case 1: return new Head_NegationParserRuleCall_1(parent, this, 1, inst);
			case 2: return new Head_MinusParserRuleCall_2(parent, this, 2, inst);
			case 3: return new Head_AtomParserRuleCall_3(parent, this, 3, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getHeadRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// BracketTerm
protected class Head_BracketTermParserRuleCall_0 extends RuleCallToken {
	
	public Head_BracketTermParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getHeadAccess().getBracketTermParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BracketTerm_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(BracketTerm_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getBracketTermRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Negation
protected class Head_NegationParserRuleCall_1 extends RuleCallToken {
	
	public Head_NegationParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getHeadAccess().getNegationParserRuleCall_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Negation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Negation_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getNegationRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Minus
protected class Head_MinusParserRuleCall_2 extends RuleCallToken {
	
	public Head_MinusParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getHeadAccess().getMinusParserRuleCall_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Minus_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Minus_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getMinusRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Atom
protected class Head_AtomParserRuleCall_3 extends RuleCallToken {
	
	public Head_AtomParserRuleCall_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getHeadAccess().getAtomParserRuleCall_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Atom_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Atom_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAtomRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule Head ****************/


/************ begin Rule Tail ****************
 *
 * Tail:
 *   operator=Operator term=Term;
 *
 **/

// operator=Operator term=Term
protected class Tail_Group extends GroupToken {
	
	public Tail_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getTailAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Tail_TermAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTailRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// operator=Operator
protected class Tail_OperatorAssignment_0 extends AssignmentToken  {
	
	public Tail_OperatorAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getTailAccess().getOperatorAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getTailAccess().getOperatorOperatorEnumRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// term=Term
protected class Tail_TermAssignment_1 extends AssignmentToken  {
	
	public Tail_TermAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getTailAccess().getTermAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Term_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("term",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("term");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTermRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTailAccess().getTermTermParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Tail_OperatorAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Tail ****************/


/************ begin Rule BracketTerm ****************
 *
 * BracketTerm:
 *   "(" term=Term ")";
 *
 **/

// "(" term=Term ")"
protected class BracketTerm_Group extends GroupToken {
	
	public BracketTerm_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getBracketTermAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BracketTerm_RightParenthesisKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getBracketTermRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "("
protected class BracketTerm_LeftParenthesisKeyword_0 extends KeywordToken  {
	
	public BracketTerm_LeftParenthesisKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getBracketTermAccess().getLeftParenthesisKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// term=Term
protected class BracketTerm_TermAssignment_1 extends AssignmentToken  {
	
	public BracketTerm_TermAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getBracketTermAccess().getTermAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Term_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("term",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("term");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTermRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBracketTermAccess().getTermTermParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BracketTerm_LeftParenthesisKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class BracketTerm_RightParenthesisKeyword_2 extends KeywordToken  {
	
	public BracketTerm_RightParenthesisKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getBracketTermAccess().getRightParenthesisKeyword_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BracketTerm_TermAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule BracketTerm ****************/


/************ begin Rule Negation ****************
 *
 * Negation:
 *   "not" head=Head;
 *
 **/

// "not" head=Head
protected class Negation_Group extends GroupToken {
	
	public Negation_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getNegationAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Negation_HeadAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getNegationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "not"
protected class Negation_NotKeyword_0 extends KeywordToken  {
	
	public Negation_NotKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getNegationAccess().getNotKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// head=Head
protected class Negation_HeadAssignment_1 extends AssignmentToken  {
	
	public Negation_HeadAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getNegationAccess().getHeadAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Head_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("head",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("head");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getHeadRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getNegationAccess().getHeadHeadParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Negation_NotKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Negation ****************/


/************ begin Rule Minus ****************
 *
 * Minus:
 *   "-" head=Head;
 *
 **/

// "-" head=Head
protected class Minus_Group extends GroupToken {
	
	public Minus_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getMinusAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Minus_HeadAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getMinusRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "-"
protected class Minus_HyphenMinusKeyword_0 extends KeywordToken  {
	
	public Minus_HyphenMinusKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getMinusAccess().getHyphenMinusKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// head=Head
protected class Minus_HeadAssignment_1 extends AssignmentToken  {
	
	public Minus_HeadAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getMinusAccess().getHeadAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Head_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("head",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("head");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getHeadRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getMinusAccess().getHeadHeadParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Minus_HyphenMinusKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Minus ****************/


/************ begin Rule Atom ****************
 *
 * Atom:
 *   Value|Variable; 
 * 			     
 * 
 * // VARIABLES & ACCESSORS
 *
 **/

// Value|Variable 
// 			     
// 
// // VARIABLES & ACCESSORS
protected class Atom_Alternatives extends AlternativesToken {

	public Atom_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getAtomAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Atom_ValueParserRuleCall_0(parent, this, 0, inst);
			case 1: return new Atom_VariableParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAtomRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// Value
protected class Atom_ValueParserRuleCall_0 extends RuleCallToken {
	
	public Atom_ValueParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getAtomAccess().getValueParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Value_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Value_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getValueRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Variable
protected class Atom_VariableParserRuleCall_1 extends RuleCallToken {
	
	public Atom_VariableParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getAtomAccess().getVariableParserRuleCall_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Variable_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Variable_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getVariableRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule Atom ****************/


/************ begin Rule Variable ****************
 *
 * Variable:
 *   name=ID accessor=Accessor?; 
 * 
 * // VARIABLES & ACCESSORS
 *
 **/

// name=ID accessor=Accessor?
protected class Variable_Group extends GroupToken {
	
	public Variable_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getVariableAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Variable_AccessorAssignment_1(parent, this, 0, inst);
			case 1: return new Variable_NameAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getVariableRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// name=ID
protected class Variable_NameAssignment_0 extends AssignmentToken  {
	
	public Variable_NameAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getVariableAccess().getNameAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getVariableAccess().getNameIDTerminalRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// accessor=Accessor?
protected class Variable_AccessorAssignment_1 extends AssignmentToken  {
	
	public Variable_AccessorAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getVariableAccess().getAccessorAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Accessor_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("accessor",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("accessor");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAccessorRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getVariableAccess().getAccessorAccessorParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Variable_NameAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Variable ****************/


/************ begin Rule Accessor ****************
 *
 * Accessor:
 *   ArrayAccessor|FieldAccessor;
 *
 **/

// ArrayAccessor|FieldAccessor
protected class Accessor_Alternatives extends AlternativesToken {

	public Accessor_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getAccessorAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Accessor_ArrayAccessorParserRuleCall_0(parent, this, 0, inst);
			case 1: return new Accessor_FieldAccessorParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAccessorRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// ArrayAccessor
protected class Accessor_ArrayAccessorParserRuleCall_0 extends RuleCallToken {
	
	public Accessor_ArrayAccessorParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getAccessorAccess().getArrayAccessorParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ArrayAccessor_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ArrayAccessor_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getArrayAccessorRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// FieldAccessor
protected class Accessor_FieldAccessorParserRuleCall_1 extends RuleCallToken {
	
	public Accessor_FieldAccessorParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getAccessorAccess().getFieldAccessorParserRuleCall_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FieldAccessor_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(FieldAccessor_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getFieldAccessorRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule Accessor ****************/


/************ begin Rule ArrayAccessor ****************
 *
 * ArrayAccessor:
 *   "[" index=Term "]" accessor=Accessor?;
 *
 **/

// "[" index=Term "]" accessor=Accessor?
protected class ArrayAccessor_Group extends GroupToken {
	
	public ArrayAccessor_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getArrayAccessorAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ArrayAccessor_AccessorAssignment_3(parent, this, 0, inst);
			case 1: return new ArrayAccessor_RightSquareBracketKeyword_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getArrayAccessorRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "["
protected class ArrayAccessor_LeftSquareBracketKeyword_0 extends KeywordToken  {
	
	public ArrayAccessor_LeftSquareBracketKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getArrayAccessorAccess().getLeftSquareBracketKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// index=Term
protected class ArrayAccessor_IndexAssignment_1 extends AssignmentToken  {
	
	public ArrayAccessor_IndexAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getArrayAccessorAccess().getIndexAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Term_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("index",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("index");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTermRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getArrayAccessorAccess().getIndexTermParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ArrayAccessor_LeftSquareBracketKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "]"
protected class ArrayAccessor_RightSquareBracketKeyword_2 extends KeywordToken  {
	
	public ArrayAccessor_RightSquareBracketKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getArrayAccessorAccess().getRightSquareBracketKeyword_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ArrayAccessor_IndexAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// accessor=Accessor?
protected class ArrayAccessor_AccessorAssignment_3 extends AssignmentToken  {
	
	public ArrayAccessor_AccessorAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getArrayAccessorAccess().getAccessorAssignment_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Accessor_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("accessor",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("accessor");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAccessorRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getArrayAccessorAccess().getAccessorAccessorParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ArrayAccessor_RightSquareBracketKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule ArrayAccessor ****************/


/************ begin Rule FieldAccessor ****************
 *
 * FieldAccessor:
 *   "." name=ID accessor=Accessor?; 
 * 	             
 * 
 * // CONSTANTS
 *
 **/

// "." name=ID accessor=Accessor?
protected class FieldAccessor_Group extends GroupToken {
	
	public FieldAccessor_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getFieldAccessorAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FieldAccessor_AccessorAssignment_2(parent, this, 0, inst);
			case 1: return new FieldAccessor_NameAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getFieldAccessorRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "."
protected class FieldAccessor_FullStopKeyword_0 extends KeywordToken  {
	
	public FieldAccessor_FullStopKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getFieldAccessorAccess().getFullStopKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// name=ID
protected class FieldAccessor_NameAssignment_1 extends AssignmentToken  {
	
	public FieldAccessor_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getFieldAccessorAccess().getNameAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FieldAccessor_FullStopKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getFieldAccessorAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// accessor=Accessor?
protected class FieldAccessor_AccessorAssignment_2 extends AssignmentToken  {
	
	public FieldAccessor_AccessorAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getFieldAccessorAccess().getAccessorAssignment_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Accessor_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("accessor",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("accessor");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAccessorRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFieldAccessorAccess().getAccessorAccessorParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new FieldAccessor_NameAssignment_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule FieldAccessor ****************/


/************ begin Rule Value ****************
 *
 * Value:
 *   StringConst|BooleanConst|NumericConst|NullConst; 
 * 
 * // CONSTANTS
 *
 **/

// StringConst|BooleanConst|NumericConst|NullConst 
// 
// // CONSTANTS
protected class Value_Alternatives extends AlternativesToken {

	public Value_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getValueAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Value_StringConstParserRuleCall_0(parent, this, 0, inst);
			case 1: return new Value_BooleanConstParserRuleCall_1(parent, this, 1, inst);
			case 2: return new Value_NumericConstParserRuleCall_2(parent, this, 2, inst);
			case 3: return new Value_NullConstParserRuleCall_3(parent, this, 3, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getValueRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// StringConst
protected class Value_StringConstParserRuleCall_0 extends RuleCallToken {
	
	public Value_StringConstParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getValueAccess().getStringConstParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StringConst_ConstAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(StringConst_ConstAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getStringConstRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// BooleanConst
protected class Value_BooleanConstParserRuleCall_1 extends RuleCallToken {
	
	public Value_BooleanConstParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getValueAccess().getBooleanConstParserRuleCall_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanConst_ConstAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(BooleanConst_ConstAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getBooleanConstRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// NumericConst
protected class Value_NumericConstParserRuleCall_2 extends RuleCallToken {
	
	public Value_NumericConstParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getValueAccess().getNumericConstParserRuleCall_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NumericConst_ConstAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(NumericConst_ConstAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getNumericConstRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// NullConst
protected class Value_NullConstParserRuleCall_3 extends RuleCallToken {
	
	public Value_NullConstParserRuleCall_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getValueAccess().getNullConstParserRuleCall_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NullConst_ConstAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(NullConst_ConstAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getNullConstRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule Value ****************/


/************ begin Rule StringConst ****************
 *
 * StringConst:
 *   const=STRING; 
 * 	     
 * //NumericConst:	const = INT; // keine kommazahlen
 *
 **/

// const=STRING
protected class StringConst_ConstAssignment extends AssignmentToken  {
	
	public StringConst_ConstAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getStringConstAccess().getConstAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getStringConstRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("const",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("const");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getStringConstAccess().getConstSTRINGTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule StringConst ****************/


/************ begin Rule NumericConst ****************
 *
 * NumericConst:
 *   const=NUMERIC; 
 * //NumericConst:	const = INT; // keine kommazahlen 
 * 	     
 * // BooleanConst:	isTrue ?= "true" | "false";
 *
 **/

// const=NUMERIC
protected class NumericConst_ConstAssignment extends AssignmentToken  {
	
	public NumericConst_ConstAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getNumericConstAccess().getConstAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getNumericConstRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("const",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("const");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getNumericConstAccess().getConstNUMERICParserRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule NumericConst ****************/


/************ begin Rule BooleanConst ****************
 *
 * BooleanConst:
 *   const=( "true" | "false" ); 
 * // BooleanConst:	isTrue ?= "true" | "false";
 *
 **/

// const=( "true" | "false" )
protected class BooleanConst_ConstAssignment extends AssignmentToken  {
	
	public BooleanConst_ConstAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getBooleanConstAccess().getConstAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getBooleanConstRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("const",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("const");
		if("true".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getBooleanConstAccess().getConstTrueKeyword_0_0();
			return obj;
		}
		if("false".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getBooleanConstAccess().getConstFalseKeyword_0_1();
			return obj;
		}
		return null;
	}

}

/************ end Rule BooleanConst ****************/


/************ begin Rule NullConst ****************
 *
 * NullConst:
 *   const="null"; 
 * 		     
 * 
 * // OPERATIONS
 *
 **/

// const="null"
protected class NullConst_ConstAssignment extends AssignmentToken  {
	
	public NullConst_ConstAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getNullConstAccess().getConstAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getNullConstRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("const",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("const");
		if("null".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getNullConstAccess().getConstNullKeyword_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule NullConst ****************/


}
