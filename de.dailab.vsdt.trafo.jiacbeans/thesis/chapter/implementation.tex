\chapter{Implementation of the transformation}
\label{chap:implementation}
%===============================%
%         Trafo stages          %
%===============================%
In this chapter, we will present the details of the transformation's implementation. We will start with the slightly modified overall transformation structure and then continue with the details of each transformation stages.

\section{Transformation Structure}
As mentioned before in section \ref{sec:vsdt}, the transformation process in the VSDT is divided into 5 stages. We've also mentioned that the default validation and structure mapping provided by the transformation framework are reuseable. For the implementation of the new transformation, the framework's DefaultBpmnValidator and BPMN2StrucBPMNTransformation are being reused, as we can see in Figure \ref{fig:implementation_stages}.

\begin{figure}[h]
	\centering	\includegraphics[width=0.5\textwidth]{images/implementation_stages.png}
	\caption{Transformation stages}
	\label{fig:implementation_stages}
\end{figure}

The Element mapping stage is implemented on the basis of the existing Bpmn2JiacV- ElementMapping. It takes a structured Bpmn as a model and transforms each pool contained in the model's business process diagram into a Java object, which represent a model of a java file holding an AgentBean class. For this implementation, a Metamodel of the Jiac AgentBean(see Figure \ref{fig:agentbean_metamodel}) was developed as an intermediate product. 

After all Pools in the business process is completely visited and transformed into AgentBean models, these models are passed over to the JET-Transformation where they will be transformed into a String which represents the content of a Java File. 
\newpage
%===============================%
%       Validation Stage        %
%===============================%
\section{Validation}
The DefaultBPMNValidation is currently used for the validation stage. However, it might be useful that a new validation, that checks whether the expressions given in the model are conform with the Java syntax, to be implemented in the future.

%===============================%
%      Structure Mapping        %
%===============================%
\section{Structure Mapping}
Similar to the validation stage, nothing new was implemented for the structure mapping stage. The default BPMN2StrucBPMN transformation of the VSDT is being reused. In this stage the structure of the process diagram (a directed graph) is being adapted to an equivalent block structure.  

%===============================%
%       Element Mapping         %
%===============================%
\section{Element Mapping}
For the element mapping implementation a visitor based 
%===============================%
%       AgentBean Model         %
%===============================%
\section{AgentBean Model}

An AgentBean model has a list of attributes, methods, action and it may also have some subprocess(because a subprocess is mapped into an inner class of the generated AgentBean).\\\\
For the content of a Method, a Script-Model was also developed. A script is basically a java code element, which can be a single CodeElement(a single line java code), a sequence which contains a list of scripts, or even a block construct such as the while loop, or a try-catch block. 

\begin{figure}[h]
	\centering\includegraphics[width=1.0\textwidth]{images/agentBean_metamodel.png}
	\caption{AgentBean - Metamodel}
	\label{fig:agentbean_metamodel}
\end{figure}

Each script implements the method \lstinline[language=Java]{public String toJavaCode()} which returns the java code representation of the script.
In the following listing we can see the implementation of the method in the IfThenElse class:
\begin{lstlisting}[language = Java, caption = toJavaCode() implementation in the IfThenElse class]
	public String toJavaCode() {
		String code = "";
		code += "if("+condition+"){\n";
		if(thenBranch!=null){
			BufferedReader reader = new BufferedReader(new StringReader(thenBranch.toJavaCode()));
			try{
				String line = reader.readLine();
				while(line!=null){
					if(!line.equals("")) code += "\t"+line+"\n";
					line = reader.readLine();
				}
			}catch(IOException e){
				code += "\t//Error occured while reading if branch\n";
			}
		}
		code+="}";
		if(elseBranch!=null){
			code+="else{\n";
			BufferedReader reader = new BufferedReader(new StringReader(elseBranch.toJavaCode()));
			try{
				String line = reader.readLine();
				while(line!=null){
					if(!line.equals("")) code += "\t"+line+"\n";
					line = reader.readLine();
				}
			}catch(IOException e){
				code += "\t//Error occured while reading else branch\n";
			}
			code+="}";
		}
		return code;
	}
\end{lstlisting}

You might notice, that this method is also responsible for the text formatting because this method will be used by the JET-Transformation and the result will then be written in a *.java File. Therefore, as you can see in line 7-11 and 21-25, a tab are added in front of each line in the then and else branch.\\\\
%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Role of MDE             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%
\textbf{The role of MDE in the Implementation}\\\\
The benefits of Model Driven Engineering are also found during the implementation of the AgentBean model. As we can see in Figure \ref{fig:agentbean_metamodel}, it is created graphically using eclipse's Ecore Tools - Ecore Diagramm. With the help of the EMF Generator each element of the model can be easily generated into JavaCode including a Factory class that can be used to instantiate an object of each generated class. This way, we only have to implement the method toJavaCode() for each newly added script, everything else are generated automatically. 


%\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%								        JET-Transformation                     %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{JET-Transformation}
The JET-Transformation consists of 4 Templates( see also Figure \ref{fig:transformation_structure}): 
\begin{enumerate}
	\item agentbeantemplate.javajet
	\item subprocesstemplate.javajet
	\item timeouteventhandler.javajet
	\item timeeventhandler.javajet
	\item messageeventhandler.javajet
\end{enumerate}

\begin{figure}[h]
	\centering\includegraphics[width=1.0\textwidth]{images/templates_structure.png}
	\caption{JET-Transformation Structure}
	\label{fig:transformation_structure}
\end{figure}

The agentbeantemplate is the main template of the implemented JET-Transformation. An instance of it's Java template class are created by the JiacBeansResultSaver and the generate method will be invoked for each AgentBean model generated in the element mapping stage. 

The subprocesstemplate is invoked by the agentbeantemplate and recursively by the subprocesstemplate itself for each subprocess contained in their argument (an agentbean model or a subprocess model). 

The three handler templates timeouteventhandler, timeeventhandler and messageeventhandler are static templates, which means the result of the generate method does not depend on the argument object. They simply add an inner class TimeoutEventHandler, TimeEventHandler or MessageEventHandler to the AgentBean. They are invoked by the agentbeantemplate if the value of the flag handlingTimeoutEvent or handlingMessageEvent of the agent bean model is true.

\section{Implementation of the Event Handlers}
The Event handlers generated by the above mentioned templates are implemented as an inner class of the generated bean.
They all have a thread as an argument that will be stopped as soon as the expected event is received. The following code listings shows the generated code of the event handlers:

\begin{lstlisting}[language=Java , caption=MessageEventHandler implementation]
class MessageEventHandler extends Thread{
		Thread toStop;
		boolean triggered = false;
		String address;
		Class payloadClass;
		SpaceObserver<IFact> observer;
		Action joinAction;
		Action leaveAction;
		IGroupAddress groupAddress;
		
		public MessageEventHandler(String channel, String payloadType, Thread toStop){
			address = channel;
			this.toStop = toStop;
			joinAction = retrieveAction(ICommunicationBean.ACTION_JOIN_GROUP);
			leaveAction = retrieveAction(ICommunicationBean.ACTION_LEAVE_GROUP);
			groupAddress = CommunicationAddressFactory.createGroupAddress(address);
			try {
				payloadClass = ClassLoader.getSystemClassLoader().loadClass(payloadType);
			} catch (ClassNotFoundException e) {
				log.error("Class "+payloadType+" not Found!");
				e.printStackTrace();
			} 
			observer = new SpaceObserver<IFact>(){
				public void notify(SpaceEvent<? extends IFact> event) {
					if(event instanceof WriteCallEvent<?>){
						Object obj = ((WriteCallEvent) event).getObject();
						if(obj instanceof IJiacMessage){
							IJiacMessage msg = (IJiacMessage)obj;
							if(msg.getHeader(IJiacMessage.Header.SEND_TO).equals(address) &&
							   payloadClass.isInstance(msg.getPayload())){
								memory.remove(msg);
								compensate();
							}
						}
					}
				}
			};		
		}
		
		public void run(){
			invoke(joinAction, new Serializable[]{groupAddress});
			memory.attach(observer);
		}
		
		public void compensate(){
			triggered = true;
			detach();
		}
		
		public void detach(){
			memory.detach(observer);
			invoke(leaveAction, new Serializable[]{groupAddress});
		}
		
		public boolean hasBeenTriggered(){
			return triggered;
		}
}
\end{lstlisting}

\begin{lstlisting}[language=Java , caption=TimeoutEventHandler implementation]
class TimeoutEventHandler extends Thread{
		long timeout;
		Thread toStop;
		boolean triggered = false;
		
		public TimeoutEventHandler(long timeout, Thread toStop){
			this.timeout = timeout;
			this.toStop = toStop;
		}
		
		public void run(){
			try {
				Thread.sleep(timeout);
				triggered = true;
				toStop.stop();
			}catch(InterruptedException e ) { }
		}
		
		public boolean hasBeenTriggered(){
			return triggered;
		}
}
\end{lstlisting}

\begin{lstlisting}[language=Java , caption=TimeEventHandler implementation]
class TimeEventHandler extends Thread{
		Date whenToStop;
		Thread toStop;
		boolean triggered = false;
		
		public TimeEventHandler(String timeExpression, Thread toStop){
			try {
				whenToStop = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ").parse(timeExpression);
			} catch (ParseException e) {
				System.out.println("ParseException: Time Expression has to be in yyyy-MM-dd'T'HH:mm:ss.SSSZ format!");
				e.printStackTrace();
			} 
			this.toStop = toStop;
		}
		
		public void run(){
			long time = whenToStop.getTime();
			while(time>System.currentTimeMillis()){
				try {
					Thread.sleep(100);
				}catch(InterruptedException e ) { }
			}
			toStop.stop();
			triggered = true;
		}
		
		public boolean hasBeenTriggered(){
			return triggered;
		}
}
\end{lstlisting}


Both TimeEventHandler and TimeoutEventHandler are used to handle time events attached to an activity. If the given time expression is a duration, then TimeoutEventHandler will be used. If the given time expression is an exact time, TimeEventHandler will be used. TimeEventHandler parses the given expression into java Date Object using the method \verb|SimpleDateFormat.parse()|, while the TimeoutEventHandler will get a long integer parsed from the time expression. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%           Merging generated and manually edited code         %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Merging generated and manually edited code}
The main challenge in generating Java code is how to handle code that has been manually edited. Fortunately, the EMF comes with a solution to this problem : \textbf{JMerge}\cite{JMERGEFAQ}. With JMerge we can...

\subsection{JMerge}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                         Open Issues                          %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Open Issues}
implementation not complete


using JET2


better mergerules to mix manually edited and generated code within a method



