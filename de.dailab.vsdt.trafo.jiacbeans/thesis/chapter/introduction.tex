\chapter{Introduction}

In this chapter we will start by introducing the motivation of this work and the problem we would like to solve. Afterwards we will then present the goals of this work and give a short outline about the following chapters.
\section{Motivation}
\label{sec:Motivation}
A common problem in the software engineering is the communication gap between the business people as a client and the IT world.  Communicating through models (normally consisting of graphical sketches), especially those which are commonly used in the client's domain such as the BPMN, clearly is a solution in bridging this gap. In the domain of multi agent systems, this communication gap is believed to be one of the reason why the agent concept is not very popular in the business world, although it has been a research topic for many years. On the other hand, webservices and service oriented architectures that address a similar problem domain have been adopted much faster by the business users.

At the moment some model driven approach has been made in order to simplify the development of multi agent systems, providing tools that allow graphical process editing and a mapping of the process into agents. Most of these approaches use a rather simple process model which often solely targets a single agent. Although such approaches can also be used for designing agents, the model has its limits in designing multi agent systems. 
  
The main motivation of this work is to present a solution to this problem, in which the development process of multi agent systems will be simplified. This will help  the concepts of software agents and multi agent systems gain more acceptance in the industry. We hope to achieve that by developing a mapping from BPMN to agents that will enable developers to create agents simply by modeling business processes.\\

\subsection{Model Driven Engineering}
Over the past few years more and more software developers have been adopting the principle of \textit{Model Driven Engineering}(MDE) where 
they no longer focus on writing programs but on creating a set of models which defines the software. By modeling the software, the developer creates documents that provide an abstract view of the software system. This should make the designed system easier to understand for non experts e.g. the stakeholders. Moreover, since models are mostly independent from any plattform or a specific programming language, they are applicable in different platforms. 

A significant number of the so called Computer Aided Software Engineering (CASE) tools has been developed to support this methodology. Beside providing support in creating and editing the models, most of these CASE tools are also equipped with transformation features that allow us to transform the model into text or even executable programs, thus increasing efficiency in the software development process. We can say that the real benefit of MDE lies in the transformation. By providing a mapping between the model and the code, we can create standardized programs, accelerate development time and minimize faults in writing the code. \\\\

\subsection{MDE in Multi Agent Systems} 
Back in 2007, an MDE-approach has been made in order to bridge the gap between the industry and the multi-agent systems. As a result, a CASE-tool called the Visual Service Design Tool (VSDT) was developed \cite{TK07}. VSDT provides the transformation of Business Process Modeling Notation (BPMN) to Business Process Execution Language (BPEL) and Java-based Intelligent Agent Componentware (JIAC) framework. This tool also allows agents to be designed using the very expressive BPMN, which is also a model that has already been manifested in the industry. With this approach, most people from the industry should be able to design software agents.

Another MDE-approach in multi-agent systems was also made by Workflows and Agents Development Environment (WADE) by introducing a workflow which defines an agent's task and can be designed graphically with the developing tool called WOLF. From this workflow a Java code will be generated. However WADE is an example that uses a simple process model which targets only a single agent. We will discuss WADE further in section \ref{sec:wade}.

In the scope of this work, we will present a combination of both approaches and develop a plugin to VSDT to enrich its transformation feature with a code generator that will transform BPMN models into executable Java code, or JIAC Agent Beans to be more specific.

\section{Goals}
\label{sec:Goals}
As mentioned above, the main goal of this work is to develop an eclipse plugin as an extension to VSDT to enrich its transformation features with a new transformation from BPMN to JIAC Agent Beans.

%\newpage
Having a code generator does not mean that developers are not required to write any code at all. The idea is to generate as much of the code where the model is able to supply with the information required. Because it is nearly impossible to put all implementation details into the model and to anticipate the possibility that the generated code will be edited manually, considerations have to be made such that conflicts should not occur when the transformation is called upon a code that has been edited manually. So the main challenge of generating executable code is to allow a regeneration of the code (e.g. when the model changes) while protecting the manually added user code. 


\section{Outline}
In chapter \ref{chap:background} we will introduce some background topics of this work, starting with JIAC (the target framework), followed by BPMN (the model), VSDT (the framework to be extended) and JET(the technology that is being used).

Chapter \ref{chap:sota} will discuss some state of the art topics related to this work such as the transformation from BPMN to BPEL, the existing transformation from BPMN to JADL which is implemented in the VSDT, and WADE, the similar approach in generating a process into java code.

In Chapter \ref{chap:mapping}, the mapping from BPMN to JIAC Agent Beans will be presented with examples showing an excerpt of the process and the associated code mapped from it. We will start with the mapping of pools and processes followed by the mapping of some workflow structures e.g. loops and gateways. Afterwards we will then present the mapping of activities and events.

Chapter \ref{chap:implementation} contains the details about the transformation's implementation, followed by an example presented in chapter \ref{chap:examples}. 

Finally in chapter \ref{chap:conclusion}, the conclusion of this work and some future works related to this topic will be presented.