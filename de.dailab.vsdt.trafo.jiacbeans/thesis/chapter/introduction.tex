\chapter{Introduction}

In this chapter, we will start by introducing the motivation of this work and the problem we want to solve. After that we will present the goals of this work and give a short outline about the following chapters.
\section{Motivation}
\label{sec:Motivation}
A common problem in the software engineering is the communication gaps between the business people as a client and the IT world.  Communicating through models, normally consists of graphical sketches, especially using those which are commonly used in the client's domain such as the BPMN, clearly is a solution in bridging these gaps. In the domain of multi agent systems, this communication gap is believed to be one of the reason why the agent concept is not very popular in the business world, although they have been a research topic for many years, while webservices and service oriented architectures that addresses a similar problem domain are adapted much faster by the business users.

At the moment, some model driven approach has been made in order to simplify the development of multi agent systems providing tools which allows graphical process editing and a mapping of the process into agents. However, most of these approaches uses a rather simple process models which sometimes only targeting a single agent.  

The main motivation of this work is to present a solution that will simplify the software development process and help bringing the concepts of software agents and multi agent systems to gain more acceptance in the industry by developing a mapping from BPMN to agents that will enable users to create agents simply by modeling business processes.\\

\subsection{Model Driven Engineering (MDE)}
Over the past few years more and more software developers have been adopting the principle of \textit{Model Driven Engineering}(MDE) where 
they no longer focus on writing programs but on creating a set of models which define the software. By modeling the software, the developer creates documents that provides an abstract view of the software system, independently from the platform or a specific programming language, making it understandable for non experts i.e. the stakeholders as well as applicable in different platforms. 

A significant number of the so called  CASE (Computer Aided Software Engineering) tools have been developed to support this methodology. Beside providing support in creating and editing the models, most of these CASE tools are also equipped with transformation features that allows us to transform the model into text or even executable programs, thus increasing efficiency in the software development process. We can say that the real benefits of MDE lies in the transformation. By providing a mapping between the model and the code, we can create standardized programs, accelerate development time and minimize faults in writing the code. \\\\

\subsection{MDE in Multi-agent systems} 
Back in 2007, an MDE-approach has been made in order to bridge the gap between the industry and the multi-agent systems. As a result, a CASE-tool called the \textbf{\textit{Visual Service Design Tool (VSDT)}} was developed by Tobias K\"uster in scope of his Diploma Thesis, which provides the transformation of BPMN (Business Process Modeling Notation) to BPEL(\textit{Business Process Execution Language}) and JIAC (Java-based Intelligent Agent Componentware) framework. This tool allows agents to be designed using the very expressive BPMN, which is also a model that has already been manifested in the industry. With this approach, most people from the industry should be able to design software agents.

Another MDE-approach in multi-agent systems are also introduced by WADE by introducing a workflow, which defines an agent's task and can be designed graphically with the developing tool WOLF and generated into a java code. But WADE is an example that uses a rather simple process model which target only a single agent. We will discuss WADE further in section \ref{sec:wade}.

In the scope of this work, we will present a combination of both approaches and develop a plugin to VSDT to enrich it's transformation feature with a code generator that will transform BPMN models into executable Java Code, or JIAC Agent Beans to be more specific.

\section{Goals}
\label{sec:Goals}
The main goal of this work is to develop an eclipse plugin as an extension to VSDT to enrich its transformation features with a new transformation from BPMN to JIAC Agent Beans. \\

%\newpage
\textbf{\textit{There will be code...} }\\
Having a code generator doesn't mean that developers won't be writing anymore code, although the idea is to generate most of the code from the informations given in the model. Because it is nearly impossible to put all implementation details into the model and to anticipate the possibility that the generated code will be edited manually, considerations has to be made such that conflicts should not occur when the transformation is called to a code that has been edited manually. So the main challenge of generating executable code is to allow a regeneration of the code (e.g. when the model changes) while protecting the manually added user code. 


\section{Outline}
In chapter \ref{chap:background} we will introduce some background topics of this work, starting with JIAC (the target framework), follwed by BPMN (the model), VSDT (the framework to be extended) and JET(the technology that is being used).

Chapter \ref{chap:sota} will discuss some State of the Art topics related to this work such as the transformation from BPMN to BPEL, the existing transformation from BPMN to JADL which is implemented in the VSDT, and WADE, the similar approach in generating a process into java code.

In Chapter \ref{chap:mapping}, the mapping from BPMN to Jiac Agent Beans will be presented with examples showing the BPMN figure and the associated code mapped from it. We will start with the mapping of pools and processes followed by the mapping of some workflow structures e.g. loops and gateways. Finally we will present the mapping of activities and events.

Chapter \ref{chap:implementation} contains the details about the transformation's implementation, followed by an example presented in chapter \ref{chap:examples}. 

Finally in chapter \ref{chap:conclusion}, the conclusion of this work and some future works related to this topic will be presented.