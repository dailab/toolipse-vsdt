package de.dailab.es;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Random;

/**
 * Optimization with MY/RHO+LAMBDA evolution strategy. First, one generation
 * of MY individuals is generated. Then, LAMBDA children of these individuals
 * are generated by recombining RHO parents for each and mutating the result.
 * From the combined parents and children the best MY individuals are selected
 * for the next generation.
 * 
 * @see ESModel
 * 
 * @author kuester
 *
 * @param <T>	Class describing the individuals
 */
public class ESEngine<T> implements Comparator<T> {

	/** random number generator */
	protected static final Random random= new Random();
	
	/** number of individuals to keep as parents for the next generation */
	protected int my= 3;
	
	/** number of parents to recombine to one new individual */
	protected int rho= 1;
	
	/** number of offspring to generate for each generation */
	protected int lambda= 5;
	
	/** randomly mutate an offspring multiple time? (for a better chance to 'break the scheme') */
	protected boolean multiMutate= true;
	
	/** keep parents of the last generation for the next? (i.e. (my+lambda)- or (my,lambda)-ES) */
	protected boolean keepParents= true;

	/** use delta? (Schrittweitensteuerung) */
	protected boolean useDelta= true;
	
	/** current delta, i.e. how strong the mutations may be */
	protected double delta= 1.0;
	
	/** last improvement as quotient of the qualities of the best old and the best new individual */
	protected double improvement= 1.0;
	
	/** the environment for which to optimize the individuals */
	protected final ESModel<T> model;
	
	/** current generation of MY individuals */
	protected List<T> current= null;
	

	/**
	 * Create ES Engine for given environment
	 * 
	 * @param model		the environment in which the individuals are situated
	 */
	public ESEngine(ESModel<T> model) {
		if (model == null) throw new IllegalArgumentException("Model must not be null!");
		this.model = model;
	}
	
	/**
	 * Setup (and reset) the evolution strategy engine.
	 * 
	 * @param my			number of individuals to keep as parents for the next generation
	 * @param rho			number of parents to recombine to one new individual
	 * @param lambda		number of offspring to generate for each generation
	 * @param multiMutate	randomly mutate an offspring multiple time? (for a better chance to 'break the scheme')
	 * @param keepParents	keep parents of the last generation for the next (i.e. (my+lambda)- or (my,lambda)-ES)
	 * @param useDelta		use delta? (Schrittweitensteuerung)
	 */
	public final void setup(int my, int rho, int lambda, boolean multiMutate, boolean keepParents, boolean useDelta) {
		this.my = my;
		this.rho = rho;
		this.lambda = lambda;
		this.multiMutate = multiMutate;
		this.keepParents = keepParents;
		this.useDelta = useDelta;
		this.delta = 1.0;
		this.improvement = 1.0;
		this.current = model.initialize(my);
	}
	
	/**
	 * Optimization with MY/RHO+LAMBDA evolution strategy. LAMBDA children are
	 * generated by recombining RHO parents from the current generation for each
	 * and mutating the result. From the combined parents and children the best 
	 * MY individuals are selected for the next generation.
	 * 
	 * @return	whether the new generation is an improvement above the old
	 */
	public final boolean generateNext() {
		// create LAMBDA recombined and/or mutated offsprings
		List<T> next= new ArrayList<T>(lambda);
		for (int i=0; i < lambda; i++) {
			// randomly select parent
			T offspring= current.get(random.nextInt(my));
			if (rho > 1) {
				// randomly select RHO parents and recombine
				List<T> parents= new ArrayList<T>(current);
				Collections.shuffle(parents, random);
				offspring= model.recombine(parents.subList(0, rho));
			}
			// create mutation of selected and add to offspring
			do {
				offspring= model.mutate(offspring, delta);
			} while (multiMutate && random.nextBoolean());
			next.add(offspring);
		}
		// select MY best individuals from (parents and) offspring
		List<T> candidates= next;
		if (keepParents) {
			candidates.addAll(current);
		}
		// sort candidates and determine improvement over last generation 
		sortByQuality(candidates);
		improvement= model.getQuality(candidates.get(0)) / model.getQuality(current.get(0));
		if (useDelta) {
			// TODO determine new delta
		}
		current= candidates.subList(0, my);
		return improvement > 1;
	}
	
	/**
	 * Sort the List by descending Quality of the objects
	 * 
	 * @param objects	individuals of one generation
	 * @return			sorted list, starting with the individuals of best quality
	 */
	public final void sortByQuality(List<T> objects) {
		Collections.sort(objects, this);
		Collections.reverse(objects);
	}
	
	/**
	 * Compare Quality of Objects.
	 * 
	 * @param o1	first object
	 * @param 02	second object
	 * @return		getQuality(o1).compareTo(getQuality(o2))
	 * 
	 */
	@Override
	public final int compare(T o1, T o2) {
		Double q1= model.getQuality(o1);
		Double q2= model.getQuality(o2);
		return q1.compareTo(q2);
	}
	
	
	// GETTER AND SETTER

	/**
	 * @return		MY individuals being the next generation's parents (or null if not initialized yet)
	 */
	public List<T> getCurrent() {
		return current;
	}
	
	/**
	 * @return		the improvement of the last generation over the generation before
	 */
	public double getImprovement() {
		return improvement;
	}
	
	/**
	 * @return		currently used delta (Schrittweite)
	 */
	public double getDelta() {
		return delta;
	}

	/**
	 * @return	best individual of current generation
	 */
	public T getBest() {
		if (current != null && ! current.isEmpty()) {
			return current.get(0);
		} else {
			return null;
		}
	}
}
